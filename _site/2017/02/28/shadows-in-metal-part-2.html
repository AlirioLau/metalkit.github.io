<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Shadows in Metal part 2</title>
  <meta name="description" content="In this second part of the series, we will be looking into soft shadows. We are going to work on the playground we used in Raymarching in Metal and build up ...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" href="https://devimages.apple.com.edgekey.net/assets/elements/icons/metal/metal-128x128_2x.png" />
  <link rel="canonical" href="http://localhost:4000/2017/02/28/shadows-in-metal-part-2.html">
  <link rel="alternate" type="application/rss+xml" title="The Metal Framework" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">The Metal Framework</a>

    <nav class="site-nav">
    
    <!--
      <a href="/archive.html" style="color:grey;">Archives</a>&nbsp;&nbsp;&nbsp;
    -->
    
      <a href="/contact.html" style="color:grey;">Contact</a>&nbsp;&nbsp;&nbsp;
      <a href="/feed.xml" style="color:grey;">RSS</a>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Shadows in Metal part 2</h1>
    <p class="post-meta"><time datetime="2017-02-28T00:00:00-06:00" itemprop="datePublished">Feb 28, 2017</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by <a href = "https://twitter.com/gpu3d" target="_blank">Marius Horga</a></span></span></p>
  </header>

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script><br /><br />

  <div class="post-content" itemprop="articleBody">
    <p>In this second part of the series, we will be looking into <strong>soft shadows</strong>. We are going to work on the playground we used in <a href="http://metalkit.org/2016/12/30/raymarching-in-metal.html">Raymarching in Metal</a> and build up on that because it was already set up for <code class="highlighter-rouge">3D</code> objects. Let’s set up a basic scene that has a sphere, a plane, a light and a ray:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">Ray</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">origin</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">direction</span><span class="p">;</span>
    <span class="kt">Ray</span><span class="p">(</span><span class="n">float3</span> <span class="n">o</span><span class="p">,</span> <span class="n">float3</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">struct</span> <span class="kt">Sphere</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">center</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">radius</span><span class="p">;</span>
    <span class="kt">Sphere</span><span class="p">(</span><span class="n">float3</span> <span class="n">c</span><span class="p">,</span> <span class="n">float</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">struct</span> <span class="kt">Plane</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">yCoord</span><span class="p">;</span>
    <span class="kt">Plane</span><span class="p">(</span><span class="n">float</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">yCoord</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">struct</span> <span class="kt">Light</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">position</span><span class="p">;</span>
    <span class="kt">Light</span><span class="p">(</span><span class="n">float3</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>Next, we create a few <code class="highlighter-rouge">distance operation</code> functions that help us determine distances between elements of the scene:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float</span> <span class="nf">unionOp</span><span class="p">(</span><span class="n">float</span> <span class="n">d0</span><span class="p">,</span> <span class="n">float</span> <span class="n">d1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">min</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">differenceOp</span><span class="p">(</span><span class="n">float</span> <span class="n">d0</span><span class="p">,</span> <span class="n">float</span> <span class="n">d1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span> <span class="o">-</span><span class="n">d1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">distToSphere</span><span class="p">(</span><span class="kt">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">Sphere</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">length</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">center</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float</span> <span class="nf">distToPlane</span><span class="p">(</span><span class="kt">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">Plane</span> <span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ray</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">plane</span><span class="o">.</span><span class="n">yCoord</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Next, we create a <strong>distanceToScene()</strong> function which gives us the closest distance to any object in the scene. We use these functions to generate a shape that looks like a hollow sphere with holes:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float</span> <span class="nf">distToScene</span><span class="p">(</span><span class="kt">Ray</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">Plane</span> <span class="n">p</span> <span class="o">=</span> <span class="kt">Plane</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">d2p</span> <span class="o">=</span> <span class="nf">distToPlane</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="kt">Sphere</span> <span class="n">s1</span> <span class="o">=</span> <span class="kt">Sphere</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span> <span class="mf">1.9</span><span class="p">);</span>
    <span class="kt">Sphere</span> <span class="n">s2</span> <span class="o">=</span> <span class="kt">Sphere</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">4.0</span><span class="p">);</span>
    <span class="kt">Sphere</span> <span class="n">s3</span> <span class="o">=</span> <span class="kt">Sphere</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">3.9</span><span class="p">);</span>
    <span class="kt">Ray</span> <span class="n">repeatRay</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
    <span class="n">repeatRay</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="nf">fract</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">origin</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">4.0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">d2s1</span> <span class="o">=</span> <span class="nf">distToSphere</span><span class="p">(</span><span class="n">repeatRay</span><span class="p">,</span> <span class="n">s1</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">d2s2</span> <span class="o">=</span> <span class="nf">distToSphere</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">d2s3</span> <span class="o">=</span> <span class="nf">distToSphere</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s3</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="nf">differenceOp</span><span class="p">(</span><span class="n">d2s2</span><span class="p">,</span> <span class="n">d2s3</span><span class="p">);</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="nf">differenceOp</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">d2s1</span><span class="p">);</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="nf">unionOp</span><span class="p">(</span><span class="n">d2p</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Everything we wrote so far is old code, just refactored from the <em>Raymarching</em> article. Let’s talk about <strong>normals</strong> and why they are needed. If we have a flat floor - like our plane - the normal is always <code class="highlighter-rouge">(0, 1, 0)</code>, that is, pointing up. This case is trivial though. The normal in <code class="highlighter-rouge">3D</code> space is a <code class="highlighter-rouge">float3</code> and we need to know its position on the ray. Assume the ray just touches the left side of the sphere. The normal should be <code class="highlighter-rouge">(-1, 0, 0)</code>, that is, pointing to the left and away from the sphere. If the ray moves slightly to the right of that point, it’s inside the sphere <code class="highlighter-rouge">(eg. -0.001)</code>. If the ray moves slightly to the left, it’s outside the sphere <code class="highlighter-rouge">(eg. 0.001)</code>. If we subtract left from right we get <code class="highlighter-rouge">-0.001 - 0.001 = -0.002</code> which points to the left, so this is our <code class="highlighter-rouge">x</code> coordinate of the normal. We then repeat this for <code class="highlighter-rouge">y</code> and <code class="highlighter-rouge">z</code>. We use a <code class="highlighter-rouge">2D</code> vector named <strong>eps</strong> so we can easily do <a href="https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)">vector swizzling</a> using the chosen value <code class="highlighter-rouge">0.001</code> for various coordinates as needed in each case:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float3</span> <span class="nf">getNormal</span><span class="p">(</span><span class="kt">Ray</span> <span class="n">ray</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">eps</span> <span class="o">=</span> <span class="nf">float2</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="nf">distToScene</span><span class="p">(</span><span class="kt">Ray</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="n">eps</span><span class="o">.</span><span class="n">xyy</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">direction</span><span class="p">))</span> <span class="o">-</span>
                      <span class="nf">distToScene</span><span class="p">(</span><span class="kt">Ray</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">eps</span><span class="o">.</span><span class="n">xyy</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">direction</span><span class="p">)),</span>
                      <span class="nf">distToScene</span><span class="p">(</span><span class="kt">Ray</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="n">eps</span><span class="o">.</span><span class="n">yxy</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">direction</span><span class="p">))</span> <span class="o">-</span>
                      <span class="nf">distToScene</span><span class="p">(</span><span class="kt">Ray</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">eps</span><span class="o">.</span><span class="n">yxy</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">direction</span><span class="p">)),</span>
                      <span class="nf">distToScene</span><span class="p">(</span><span class="kt">Ray</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="n">eps</span><span class="o">.</span><span class="n">yyx</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">direction</span><span class="p">))</span> <span class="o">-</span>
                      <span class="nf">distToScene</span><span class="p">(</span><span class="kt">Ray</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">eps</span><span class="o">.</span><span class="n">yyx</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">direction</span><span class="p">)));</span>
    <span class="k">return</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Finally, we are ready to see some visuals. We again use the old <code class="highlighter-rouge">Raymarching</code> code and at the end of the kernel function we just add the normal so we can interpolate it with the color for every pixel:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">kernel</span> <span class="n">void</span> <span class="nf">compute</span><span class="p">(</span><span class="n">texture2d</span><span class="o">&lt;</span><span class="n">float</span><span class="p">,</span> <span class="nv">access</span><span class="p">::</span><span class="n">write</span><span class="o">&gt;</span> <span class="n">output</span> <span class="p">[[</span><span class="nf">texture</span><span class="p">(</span><span class="mi">0</span><span class="p">)]],</span>
                    <span class="n">constant</span> <span class="n">float</span> <span class="o">&amp;</span><span class="n">time</span> <span class="p">[[</span><span class="nf">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)]],</span>
                    <span class="n">uint2</span> <span class="n">gid</span> <span class="p">[[</span><span class="n">thread_position_in_grid</span><span class="p">]])</span> <span class="p">{</span>
    <span class="n">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="nf">get_width</span><span class="p">();</span>
    <span class="n">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="nf">get_height</span><span class="p">();</span>
    <span class="n">float2</span> <span class="n">uv</span> <span class="o">=</span> <span class="nf">float2</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span> <span class="o">/</span> <span class="nf">float2</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="n">uv</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">uv</span><span class="o">.</span><span class="n">y</span><span class="p">;</span>
    <span class="kt">Ray</span> <span class="n">ray</span> <span class="o">=</span> <span class="kt">Ray</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="p">,</span> <span class="mi">4</span><span class="o">.</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">),</span> <span class="nf">normalize</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">1</span><span class="o">.</span><span class="p">)));</span>
    <span class="n">float3</span> <span class="n">col</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="nf">distToScene</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">+=</span> <span class="n">ray</span><span class="o">.</span><span class="n">direction</span> <span class="o">*</span> <span class="n">dist</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">float3</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">getNormal</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
    <span class="n">output</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">gid</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>If you run the playground now you should see a similar image:</p>

<p><img src="https://github.com/MetalKit/images/raw/master/shadows_4.png" alt="alt text" title="4" /></p>

<p>Now that we have normals, we can calculate lighting for each pixel in the scene, using the <strong>lighting()</strong> function. First we need to know the direction to the light (<code class="highlighter-rouge">lightRay</code>) which we get by normalizing the light position and the current ray. For <strong>diffuse</strong> lighting we need the angle between the normal and the <code class="highlighter-rouge">lightRay</code>, that is, the dot product of the two. For <strong>specular</strong> lighting we need reflections on surfaces, and they depend on the angle we’re looking at. The difference is in this case we first cast a ray into the scene, reflect it from the surface and then we measure the angle between the reflected ray and the <code class="highlighter-rouge">lightRay</code>. We then take a high power of that value to make it much sharper. Finally we return the combined light:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float</span> <span class="nf">lighting</span><span class="p">(</span><span class="kt">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="n">float3</span> <span class="n">normal</span><span class="p">,</span> <span class="kt">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">lightRay</span> <span class="o">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">light</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">ray</span><span class="o">.</span><span class="n">origin</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nf">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">lightRay</span><span class="p">));</span>
    <span class="n">float3</span> <span class="n">reflectedRay</span> <span class="o">=</span> <span class="nf">reflect</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">specular</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nf">dot</span><span class="p">(</span><span class="n">reflectedRay</span><span class="p">,</span> <span class="n">lightRay</span><span class="p">));</span>
    <span class="n">specular</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="n">specular</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Replace the last line in the kernel function with these lines:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">Light</span> <span class="n">light</span> <span class="o">=</span> <span class="kt">Light</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="nf">sin</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="nf">cos</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">));</span>
<span class="n">float</span> <span class="n">l</span> <span class="o">=</span> <span class="nf">lighting</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">light</span><span class="p">);</span>
<span class="n">output</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">gid</span><span class="p">);</span></code></pre></figure>

<p>If you run the playground now you should see a similar image:</p>

<p><img src="https://github.com/MetalKit/images/raw/master/shadows_5.png" alt="alt text" title="5" /></p>

<p>Next, shadows! We pretty much use the <strong>shadow()</strong> function from the first part of this series, with few modifications. We normalize the direction of the light (<code class="highlighter-rouge">lightDir</code>) and then we just keep updating <code class="highlighter-rouge">distAlongRay</code> as we march along the ray:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float</span> <span class="nf">shadow</span><span class="p">(</span><span class="kt">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">Light</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">light</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">ray</span><span class="o">.</span><span class="n">origin</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">lightDist</span> <span class="o">=</span> <span class="nf">length</span><span class="p">(</span><span class="n">lightDir</span><span class="p">);</span>
    <span class="n">lightDir</span> <span class="o">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">lightDir</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">distAlongRay</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">Ray</span> <span class="n">lightRay</span> <span class="o">=</span> <span class="kt">Ray</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="n">lightDir</span> <span class="o">*</span> <span class="n">distAlongRay</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="nf">distToScene</span><span class="p">(</span><span class="n">lightRay</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mf">0.0</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">distAlongRay</span> <span class="o">+=</span> <span class="n">dist</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distAlongRay</span> <span class="o">&gt;</span> <span class="n">lightDist</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Replace the last line in the kernel function with these lines:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">shadow</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">light</span><span class="p">);</span>
<span class="n">output</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="n">l</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">gid</span><span class="p">);</span></code></pre></figure>

<p>If you run the playground now you should see a similar image:</p>

<p><img src="https://github.com/MetalKit/images/raw/master/shadows_6.png" alt="alt text" title="6" /></p>

<p>Let’s get some <code class="highlighter-rouge">soft shadows</code> in the scene. In real life, a shadow spreads out the farther it gets from an object. For example, if there is a cube on the floor, at a cube’s vertex we get a sharp shadow but farther away from the cube it looks more like a blurred shadow. In other words, we start at some point on the floor, we march towards the light and either hit or miss. Hard shadows are straightforward: we hit something, it’s in the shadow. Soft shadows have in-between stages. Update the <strong>shadow()</strong> function with these lines:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float</span> <span class="nf">shadow</span><span class="p">(</span><span class="kt">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="n">float</span> <span class="n">k</span><span class="p">,</span> <span class="kt">Light</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">ray</span><span class="o">.</span><span class="n">origin</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">lightDist</span> <span class="o">=</span> <span class="nf">length</span><span class="p">(</span><span class="n">lightDir</span><span class="p">);</span>
    <span class="n">lightDir</span> <span class="o">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">lightDir</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">distAlongRay</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">light</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">Ray</span> <span class="n">lightRay</span> <span class="o">=</span> <span class="kt">Ray</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="n">lightDir</span> <span class="o">*</span> <span class="n">distAlongRay</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="nf">distToScene</span><span class="p">(</span><span class="n">lightRay</span><span class="p">);</span>
        <span class="n">light</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">light</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">eps</span> <span class="o">-</span> <span class="n">dist</span><span class="p">)</span> <span class="o">/</span> <span class="n">eps</span><span class="p">);</span>
        <span class="n">distAlongRay</span> <span class="o">+=</span> <span class="n">dist</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="n">eps</span> <span class="o">+=</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distAlongRay</span> <span class="o">&gt;</span> <span class="n">lightDist</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">light</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>You will notice that we are starting with a white (<code class="highlighter-rouge">1.0</code>) light this time and we use an attenuator (<strong>k</strong>) to get various (intermediate) values of light. The <strong>eps</strong> variable tells us how much wider the beam is as we go out into the scene. A thin beam means sharp shadow while a wide beam means soft shadow. We start with a small <code class="highlighter-rouge">distAlongRay</code> because otherwise the surface at this point would shadow itself. We then travel along the ray as we did for the hard shadows, then we get the distance to the scene, after that we subtract <code class="highlighter-rouge">dist</code> from <code class="highlighter-rouge">eps</code> (the beam width) and divide it by <code class="highlighter-rouge">eps</code>. This gives us the percentage of beam covered. If we invert it (<code class="highlighter-rouge">1 - beam width</code>) we get the percentage of beam that is in the light. We take the minimum of this new value and <code class="highlighter-rouge">light</code> to preserve the darkest shadow as we march along the ray. We then again move along the ray and increase the beam width in proportion to the distance traveled and scaled by <code class="highlighter-rouge">k</code>. If we’re past the light, we break out of the loop. Finally, we want to avoid negative values for the light so we return the maximum between <strong>0.0</strong> and the value of light. Now let’s adapt the kernel code to work with the new <code class="highlighter-rouge">shadow()</code> function:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float3</span> <span class="n">col</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">hit</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">200</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="nf">distToScene</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">+=</span> <span class="n">ray</span><span class="o">.</span><span class="n">direction</span> <span class="o">*</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hit</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">col</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">getNormal</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
    <span class="kt">Light</span> <span class="n">light</span> <span class="o">=</span> <span class="kt">Light</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="nf">sin</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="nf">cos</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">));</span>
    <span class="n">float</span> <span class="n">l</span> <span class="o">=</span> <span class="nf">lighting</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">light</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">shadow</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">light</span><span class="p">);</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">col</span> <span class="o">*</span> <span class="n">l</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">Light</span> <span class="n">light2</span> <span class="o">=</span> <span class="kt">Light</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">15.0</span><span class="p">));</span>
<span class="n">float3</span> <span class="n">lightRay</span> <span class="o">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">light2</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">ray</span><span class="o">.</span><span class="n">origin</span><span class="p">);</span>
<span class="n">float</span> <span class="n">fl</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nf">dot</span><span class="p">(</span><span class="nf">getNormal</span><span class="p">(</span><span class="n">ray</span><span class="p">),</span> <span class="n">lightRay</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="n">col</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">fl</span><span class="p">;</span>
<span class="n">output</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">gid</span><span class="p">);</span></code></pre></figure>

<p>Notice we switched to having a rather white color by default. Then we added a boolean named <strong>hit</strong> that tells us if we hit the object or not. We determine we have a hit if the distance to scene is within <strong>0.001</strong>. If we didn’t hit anything, just color everything in grey, otherwise determine the shadow value. At the end we just add another (fixed) light source in front of the scene so see the shadows in greater detail. If you run the playground now you should see a similar image:</p>

<p><img src="https://github.com/MetalKit/images/raw/master/shadows_7.png" alt="alt text" title="7" /></p>

<p>To see an animated version of this code, use the <code class="highlighter-rouge">Shadertoy</code> embedded player below. Just hover over it and click the play button to watch it in action:</p>

<iframe width="740" height="450" frameborder="0" src="https://www.shadertoy.com/embed/XltSWf" allowfullscreen=""></iframe>
<p><br /></p>

<p>The <a href="https://github.com/MetalKit/metal">source code</a> is posted on <code class="highlighter-rouge">Github</code> as usual.</p>

<p>Until next time!</p>

  </div>

  <!-- 
    

   -->

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style"><br />
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script>
</article>
      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper" align="center">

    <!-- <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p> -->

    <!-- Begin MailChimp Signup Form --><p>
    <link href="//cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
    <style type="text/css">
      #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
    </style>
    <div id="mc_embed_signup">
      <form action="//github.us12.list-manage.com/subscribe/post?u=5daab344aba23020915a23c29&amp;id=69e4a7c3af" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
          <div id="mc_embed_signup_scroll">
        <label for="mce-EMAIL">Subscribe to be notified of new posts.</label>
        <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
          <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_5daab344aba23020915a23c29_69e4a7c3af" tabindex="-1" value=""></div>
          <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
          </div>
      </form>
    </div>
    </p><!--End mc_embed_signup-->

    <!-- <h2 class="footer-heading">The Metal Framework</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p>
        <ul class="contact-list">
          <li>
            
              The Metal Framework
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/MetalKit"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">MetalKit</span></a>

          </li>
          
          
          <li>
            <a href="https://twitter.com/gpu3d"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">gpu3d</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        
          <a href="https://twitter.com/gpu3d"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">gpu3d</span></a>

        
        <p>Resources and tutorials for Metal, MetalKit and Metal Performance Shaders.
</p>
      </div>
    </div> -->

  </div>

</footer>


  </body>

</html>
