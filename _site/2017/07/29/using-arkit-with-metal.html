<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Using ARKit with Metal</title>
  <meta name="description" content="Augmented Reality provides a way of overlaying virtual content on top of real world views usually obtained from a mobile device camera. Last month at WWDC 20...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" href="https://devimages.apple.com.edgekey.net/assets/elements/icons/metal/metal-128x128_2x.png" />
  <link rel="canonical" href="http://localhost:4000/2017/07/29/using-arkit-with-metal.html">
  <link rel="alternate" type="application/rss+xml" title="The Metal Framework" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">The Metal Framework</a>

    <nav class="site-nav">
      <a href="/archive.html" style="color:grey;">Archives</a>&nbsp;&nbsp;&nbsp;
      <a href="/contact.html" style="color:grey;">Contact</a>&nbsp;&nbsp;&nbsp;
      <a href="/feed.xml" style="color:grey;">RSS</a>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Using ARKit with Metal</h1>
    <p class="post-meta"><time datetime="2017-07-29T00:00:00-05:00" itemprop="datePublished">Jul 29, 2017</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name"><a href = "https://twitter.com/gpu3d" target="_blank">Marius Horga</a></span></span></p>
  </header>

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script><br /><br />

  <div class="post-content" itemprop="articleBody">
    <p><strong>Augmented Reality</strong> provides a way of overlaying virtual content on top of real world views usually obtained from a mobile device camera. Last month at <code class="highlighter-rouge">WWDC 2017</code> we were all thrilled to see <code class="highlighter-rouge">Apple</code>’s new <strong>ARKit</strong> framework which is a high level <code class="highlighter-rouge">API</code> that works with <code class="highlighter-rouge">A9</code>-powered devices or newer, running on <code class="highlighter-rouge">iOS 11</code>. Some of the ARKit experiments we’ve already seen are outstanding, such as this one below:</p>

<p>￼￼<img src="https://github.com/MetalKit/images/blob/master/ARKit.gif?raw=true" alt="alt text" title="ARKit" /></p>

<p>There are three distinct layers in an <code class="highlighter-rouge">ARKit</code> application:</p>

<ul>
  <li><strong>Tracking</strong> - no external setup is necessary to do world tracking using visual inertial odometry.</li>
  <li><strong>Scene Understanding</strong> - the ability of detecting scene attributes using plane detection, hit-testing and light estimation.</li>
  <li><strong>Rendering</strong> - can be easily integrated because of the template <code class="highlighter-rouge">AR</code> views provided by <code class="highlighter-rouge">SpriteKit</code> and <code class="highlighter-rouge">SceneKit</code> but it can also be customized for <code class="highlighter-rouge">Metal</code>. all the pre-render processing is done by <code class="highlighter-rouge">ARKit</code> which is also responsible for image capturing using <code class="highlighter-rouge">AVFoundation</code> and <code class="highlighter-rouge">CoreMotion</code>.</li>
</ul>

<p>In this first part of the series we will be looking mostly at <code class="highlighter-rouge">Rendering</code> in <code class="highlighter-rouge">Metal</code> and talk about most of the other two stages for the next part of this series. In an <code class="highlighter-rouge">AR</code> application, the <code class="highlighter-rouge">Tracking</code> and <code class="highlighter-rouge">Scene Understanding</code> are handled entirely by the <code class="highlighter-rouge">ARKit</code> framework while <code class="highlighter-rouge">Rendering</code> can be handled by either <code class="highlighter-rouge">SpriteKit</code>, <code class="highlighter-rouge">SceneKit</code> or <code class="highlighter-rouge">Metal</code>:</p>

<p>￼￼<img src="https://github.com/MetalKit/images/blob/master/ARKit1.png?raw=true" alt="alt text" title="ARKit 1" /></p>

<p>To get started, we need to have an <strong>ARSession</strong> instance that is set up by an <strong>ARSessionConfiguration</strong> object. Then, we call the <strong>run()</strong> function on this configuration. The session also has <strong>AVCaptureSession</strong> and <strong>CMMotionManager</strong> objects running at the same time to get image and motion data for tracking. Finally, the session will output the current frame to an <strong>ARFrame</strong> object:</p>

<p><img src="https://github.com/MetalKit/images/blob/master/ARKit2.png?raw=true" alt="alt text" title="ARKit 2" /></p>

<p>The <code class="highlighter-rouge">ARSessionConfiguration</code> object contains information about the type of tracking the session will have. The <code class="highlighter-rouge">ARSessionConfiguration</code> base configuration class provides <strong>3</strong> degrees of freedom tracking (the device <em>orientation</em>) while its subclass, <strong>ARWorldTrackingSessionConfiguration</strong>, provides <strong>6</strong> degrees of freedom tracking (the device <em>position</em> and <em>orientation</em>).</p>

<p><img src="https://github.com/MetalKit/images/blob/master/ARKit4.png?raw=true" alt="alt text" title="ARKit 4" /></p>

<p>When a device does not support world tracking, it falls back to the base  configuration:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">if</span> <span class="kt">ARWorldTrackingSessionConfiguration</span><span class="o">.</span><span class="n">isSupported</span> <span class="p">{</span> 
    <span class="n">configuration</span> <span class="o">=</span> <span class="kt">ARWorldTrackingSessionConfiguration</span><span class="p">()</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">configuration</span> <span class="o">=</span> <span class="kt">ARSessionConfiguration</span><span class="p">()</span> 
<span class="p">}</span></code></pre></figure>

<p>An <code class="highlighter-rouge">ARFrame</code> contains the captured image, tracking information and well as scene information via <strong>ARAnchor</strong> objects that contain information about real world position and orientation and can be easily added, updated or removed from sessions. <code class="highlighter-rouge">Tracking</code> is the ability to determine the physical location in real time. The <code class="highlighter-rouge">World Tracking</code> however, determines both position and orientation, it works with physical distances, it’s relative to the starting position and provides <code class="highlighter-rouge">3D</code>-feature points.</p>

<p>The last component of an <code class="highlighter-rouge">ARFrame</code> are <strong>ARCamera</strong> objects which facilitate transforms (translation, rotation, scaling) and carry tracking state and camera intrinsics. The quality of tracking relies heavily on uninterrupted sensor data, static scenes and is more accurate when scenes have textured environment with plenty of complexity. Tracking state has three values: <strong>Not Available</strong> (camera only has the identity matrix), <strong>Limited</strong> (scene has insufficient features or is not static enough) and <strong>Normal</strong> (camera is populated with data). Session interruptions are caused by camera input not being available or when tracking is stopped:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">session</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">ARSession</span><span class="p">,</span> <span class="n">cameraDidChangeTrackingState</span> <span class="nv">camera</span><span class="p">:</span> <span class="kt">ARCamera</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">if</span> <span class="k">case</span> <span class="o">.</span><span class="nf">limited</span><span class="p">(</span><span class="k">let</span> <span class="nv">reason</span><span class="p">)</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">trackingState</span> <span class="p">{</span>
        <span class="c1">// Notify user of limited tracking state</span>
    <span class="p">}</span> 
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">sessionWasInterrupted</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">ARSession</span><span class="p">)</span> <span class="p">{</span> 
    <span class="nf">showOverlay</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">sessionInterruptionEnded</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">ARSession</span><span class="p">)</span> <span class="p">{</span> 
    <span class="nf">hideOverlay</span><span class="p">()</span>
    <span class="c1">// Optionally restart experience</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">Rendering</code> can be done in <code class="highlighter-rouge">SceneKit</code> using the <code class="highlighter-rouge">ARSCNView</code>’s delegate to add, update or remove nodes. Similarly, rendering can be done in <code class="highlighter-rouge">SpriteKit</code> using the <code class="highlighter-rouge">ARSKView</code> delegate which maps <code class="highlighter-rouge">SKNodes</code> to <code class="highlighter-rouge">ARAnchor</code> objects. Since <code class="highlighter-rouge">SpriteKit</code> is <code class="highlighter-rouge">2D</code>, it cannot use the real world camera position, so it projects the anchor positions into the <code class="highlighter-rouge">ARSKView</code> and then renders the sprite as a billboard (plane) at this projected location, so the sprite will always be facing the camera. For <code class="highlighter-rouge">Metal</code>, there is no customized <code class="highlighter-rouge">AR</code> view so that responsibility falls in programmer’s hands. For processing of rendered images we need to:</p>

<ul>
  <li>draw background camera image (generate a texture from the pixel buffer)</li>
  <li>update the virtual camera</li>
  <li>update the lighting</li>
  <li>update the transforms for geometry</li>
</ul>

<p>All this information is in the <code class="highlighter-rouge">ARFrame</code> object. To access the frame, there are two options: <em>polling</em> or using a <em>delegate</em>. We are going to describe the latter. I took the <code class="highlighter-rouge">ARKit</code> template for <code class="highlighter-rouge">Metal</code> and stripped it down to a minimum so I can better understand how it works. First thing I did was to remove all the <code class="highlighter-rouge">C</code> dependencies so a bridging is not necessary anymore. It will be useful in the future to have it in place so types and enum constants can be shared between <code class="highlighter-rouge">API</code> code and shaders but for the purpose of this article it is not needed.</p>

<p>Next, on to <strong>ViewController</strong> which will act as both our <code class="highlighter-rouge">MTKView</code> and <code class="highlighter-rouge">ARSession</code> delegates. We create a <code class="highlighter-rouge">Renderer</code> instance that will work with the delegates for real time updates to the application:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">ARSession</span><span class="o">!</span>
<span class="k">var</span> <span class="nv">renderer</span><span class="p">:</span> <span class="kt">Renderer</span><span class="o">!</span>

<span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
    <span class="n">session</span> <span class="o">=</span> <span class="kt">ARSession</span><span class="p">()</span>
    <span class="n">session</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">view</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">view</span> <span class="k">as?</span> <span class="kt">MTKView</span> <span class="p">{</span>
        <span class="n">view</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="kt">MTLCreateSystemDefaultDevice</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
        <span class="n">renderer</span> <span class="o">=</span> <span class="kt">Renderer</span><span class="p">(</span><span class="nv">session</span><span class="p">:</span> <span class="n">session</span><span class="p">,</span> <span class="nv">metalDevice</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">device</span><span class="o">!</span><span class="p">,</span> <span class="nv">renderDestination</span><span class="p">:</span> <span class="n">view</span><span class="p">)</span>
        <span class="n">renderer</span><span class="o">.</span><span class="nf">drawRectResized</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">tapGesture</span> <span class="o">=</span> <span class="kt">UITapGestureRecognizer</span><span class="p">(</span><span class="nv">target</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="kd">#selector(</span><span class="nf">self.handleTap(gestureRecognize:)</span><span class="kd">)</span><span class="p">)</span>
    <span class="n">view</span><span class="o">.</span><span class="nf">addGestureRecognizer</span><span class="p">(</span><span class="n">tapGesture</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>As you can see, we also added a gesture recognizer which we will use to add virtual content to our view. We first get the session’s current frame, then create a translation to put our object in front of the camera (<strong>0.3</strong> meters in this case) and finally add a new anchor to our session using this transform:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">handleTap</span><span class="p">(</span><span class="nv">gestureRecognize</span><span class="p">:</span> <span class="kt">UITapGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">currentFrame</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">currentFrame</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">translation</span> <span class="o">=</span> <span class="n">matrix_identity_float4x4</span>
        <span class="n">translation</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="mi">3</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.3</span>
        <span class="k">let</span> <span class="nv">transform</span> <span class="o">=</span> <span class="nf">simd_mul</span><span class="p">(</span><span class="n">currentFrame</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">translation</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">anchor</span> <span class="o">=</span> <span class="kt">ARAnchor</span><span class="p">(</span><span class="nv">transform</span><span class="p">:</span> <span class="n">transform</span><span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">anchor</span><span class="p">:</span> <span class="n">anchor</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We use the <strong>viewWillAppear()</strong> and <strong>viewWillDisappear()</strong> methods to start and pause the session:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">override</span> <span class="kd">func</span> <span class="nf">viewWillAppear</span><span class="p">(</span><span class="n">_</span> <span class="nv">animated</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewWillAppear</span><span class="p">(</span><span class="n">animated</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">configuration</span> <span class="o">=</span> <span class="kt">ARWorldTrackingSessionConfiguration</span><span class="p">()</span>
    <span class="n">session</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">override</span> <span class="kd">func</span> <span class="nf">viewWillDisappear</span><span class="p">(</span><span class="n">_</span> <span class="nv">animated</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewWillDisappear</span><span class="p">(</span><span class="n">animated</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="nf">pause</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>What’s left is only the delegate methods which we need to react to view updates or session errors and interruptions:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">mtkView</span><span class="p">(</span><span class="n">_</span> <span class="nv">view</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">,</span> <span class="n">drawableSizeWillChange</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">renderer</span><span class="o">.</span><span class="nf">drawRectResized</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="k">in</span> <span class="nv">view</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">renderer</span><span class="o">.</span><span class="nf">update</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">session</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">ARSession</span><span class="p">,</span> <span class="n">didFailWithError</span> <span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="nf">sessionWasInterrupted</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">ARSession</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="nf">sessionInterruptionEnded</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">ARSession</span><span class="p">)</span> <span class="p">{}</span></code></pre></figure>

<p>Let’s move to the <strong>Renderer.swift</strong> file now. The first thing to notice is the use of a very handy protocol that will give us access to all the <code class="highlighter-rouge">MTKView</code> properties we need for the draw call later:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">protocol</span> <span class="kt">RenderDestinationProvider</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">currentRenderPassDescriptor</span><span class="p">:</span> <span class="kt">MTLRenderPassDescriptor</span><span class="p">?</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">currentDrawable</span><span class="p">:</span> <span class="kt">CAMetalDrawable</span><span class="p">?</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">colorPixelFormat</span><span class="p">:</span> <span class="kt">MTLPixelFormat</span> <span class="p">{</span> <span class="k">get</span> <span class="k">set</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">depthStencilPixelFormat</span><span class="p">:</span> <span class="kt">MTLPixelFormat</span> <span class="p">{</span> <span class="k">get</span> <span class="k">set</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">sampleCount</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">get</span> <span class="k">set</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Now you can simply extend the <code class="highlighter-rouge">MTKView</code> class (in <code class="highlighter-rouge">ViewController</code>) so it conforms to this protocol:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">MTKView</span> <span class="p">:</span> <span class="kt">RenderDestinationProvider</span> <span class="p">{}</span></code></pre></figure>

<p>To have a high level view of the <code class="highlighter-rouge">Renderer</code> class, here is the pseudocode:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">setupPipeline</span><span class="p">()</span>
    <span class="nf">setupAssets</span><span class="p">()</span>
<span class="p">}</span>
    
<span class="kd">func</span> <span class="nf">update</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">updateBufferStates</span><span class="p">()</span>
    <span class="nf">updateSharedUniforms</span><span class="p">()</span>
    <span class="nf">updateAnchors</span><span class="p">()</span>
    <span class="nf">updateCapturedImageTextures</span><span class="p">()</span>
    <span class="nf">updateImagePlane</span><span class="p">()</span>
    <span class="nf">drawCapturedImage</span><span class="p">()</span>
    <span class="nf">drawAnchorGeometry</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>As always, we first setup the pipeline, here with the <strong>setupPipeline()</strong> function. Then, in <strong>setupAssets()</strong> we create our model which will be loaded every time we use our tap gesture recognizer. The <code class="highlighter-rouge">MTKView</code> delegate will call the <strong>update()</strong> function for the needed updates and draw calls. Let’s look at each of them in detail. First we have <strong>updateBufferStates()</strong> which updates the locations we write to in our buffers for the current frame (we use a ring buffer with <strong>3</strong> slots in this case):</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">updateBufferStates</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">uniformBufferIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">uniformBufferIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">maxBuffersInFlight</span>
    <span class="n">sharedUniformBufferOffset</span> <span class="o">=</span> <span class="n">alignedSharedUniformSize</span> <span class="o">*</span> <span class="n">uniformBufferIndex</span>
    <span class="n">anchorUniformBufferOffset</span> <span class="o">=</span> <span class="n">alignedInstanceUniformSize</span> <span class="o">*</span> <span class="n">uniformBufferIndex</span>
    <span class="n">sharedUniformBufferAddress</span> <span class="o">=</span> <span class="n">sharedUniformBuffer</span><span class="o">.</span><span class="nf">contents</span><span class="p">()</span><span class="o">.</span><span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">sharedUniformBufferOffset</span><span class="p">)</span>
    <span class="n">anchorUniformBufferAddress</span> <span class="o">=</span> <span class="n">anchorUniformBuffer</span><span class="o">.</span><span class="nf">contents</span><span class="p">()</span><span class="o">.</span><span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">anchorUniformBufferOffset</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Next, in <strong>updateSharedUniforms()</strong> we update the shared uniforms of the frame and set up lighting for the scene:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">updateSharedUniforms</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="kt">ARFrame</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">uniforms</span> <span class="o">=</span> <span class="n">sharedUniformBufferAddress</span><span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">SharedUniforms</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="n">uniforms</span><span class="o">.</span><span class="n">pointee</span><span class="o">.</span><span class="n">viewMatrix</span> <span class="o">=</span> <span class="nf">simd_inverse</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">transform</span><span class="p">)</span>
    <span class="n">uniforms</span><span class="o">.</span><span class="n">pointee</span><span class="o">.</span><span class="n">projectionMatrix</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="nf">projectionMatrix</span><span class="p">(</span><span class="nv">withViewportSize</span><span class="p">:</span> <span class="n">viewportSize</span><span class="p">,</span> <span class="nv">orientation</span><span class="p">:</span> <span class="o">.</span><span class="n">landscapeRight</span><span class="p">,</span> <span class="nv">zNear</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">,</span> <span class="nv">zFar</span><span class="p">:</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="k">var</span> <span class="nv">ambientIntensity</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">lightEstimate</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">lightEstimate</span> <span class="p">{</span>
        <span class="n">ambientIntensity</span> <span class="o">=</span> <span class="kt">Float</span><span class="p">(</span><span class="n">lightEstimate</span><span class="o">.</span><span class="n">ambientIntensity</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">ambientLightColor</span><span class="p">:</span> <span class="n">vector_float3</span> <span class="o">=</span> <span class="nf">vector3</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">uniforms</span><span class="o">.</span><span class="n">pointee</span><span class="o">.</span><span class="n">ambientLightColor</span> <span class="o">=</span> <span class="n">ambientLightColor</span> <span class="o">*</span> <span class="n">ambientIntensity</span>
    <span class="k">var</span> <span class="nv">directionalLightDirection</span> <span class="p">:</span> <span class="n">vector_float3</span> <span class="o">=</span> <span class="nf">vector3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">directionalLightDirection</span> <span class="o">=</span> <span class="nf">simd_normalize</span><span class="p">(</span><span class="n">directionalLightDirection</span><span class="p">)</span>
    <span class="n">uniforms</span><span class="o">.</span><span class="n">pointee</span><span class="o">.</span><span class="n">directionalLightDirection</span> <span class="o">=</span> <span class="n">directionalLightDirection</span>
    <span class="k">let</span> <span class="nv">directionalLightColor</span><span class="p">:</span> <span class="n">vector_float3</span> <span class="o">=</span> <span class="nf">vector3</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
    <span class="n">uniforms</span><span class="o">.</span><span class="n">pointee</span><span class="o">.</span><span class="n">directionalLightColor</span> <span class="o">=</span> <span class="n">directionalLightColor</span> <span class="o">*</span> <span class="n">ambientIntensity</span>
    <span class="n">uniforms</span><span class="o">.</span><span class="n">pointee</span><span class="o">.</span><span class="n">materialShininess</span> <span class="o">=</span> <span class="mi">30</span>
<span class="p">}</span></code></pre></figure>

<p>Next, in <strong>updateAnchors()</strong> we update the anchor uniform buffer with transforms of the current frame’s anchors:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">updateAnchors</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="kt">ARFrame</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">anchorInstanceCount</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">anchors</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">maxAnchorInstanceCount</span><span class="p">)</span>
    <span class="k">var</span> <span class="nv">anchorOffset</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">anchorInstanceCount</span> <span class="o">==</span> <span class="n">maxAnchorInstanceCount</span> <span class="p">{</span>
        <span class="n">anchorOffset</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">anchors</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="n">maxAnchorInstanceCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">anchorInstanceCount</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">anchor</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">anchors</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">anchorOffset</span><span class="p">]</span>
        <span class="k">var</span> <span class="nv">coordinateSpaceTransform</span> <span class="o">=</span> <span class="n">matrix_identity_float4x4</span>
        <span class="n">coordinateSpaceTransform</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="k">let</span> <span class="nv">modelMatrix</span> <span class="o">=</span> <span class="nf">simd_mul</span><span class="p">(</span><span class="n">anchor</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">coordinateSpaceTransform</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">anchorUniforms</span> <span class="o">=</span> <span class="n">anchorUniformBufferAddress</span><span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">InstanceUniforms</span><span class="o">.</span><span class="k">self</span><span class="p">)</span><span class="o">.</span><span class="nf">advanced</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">anchorUniforms</span><span class="o">.</span><span class="n">pointee</span><span class="o">.</span><span class="n">modelMatrix</span> <span class="o">=</span> <span class="n">modelMatrix</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Next, in <strong>updateCapturedImageTextures()</strong> we create two textures from the provided frame’s captured image:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">updateCapturedImageTextures</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="kt">ARFrame</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">pixelBuffer</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">capturedImage</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">CVPixelBufferGetPlaneCount</span><span class="p">(</span><span class="n">pixelBuffer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
    <span class="n">capturedImageTextureY</span> <span class="o">=</span> <span class="nf">createTexture</span><span class="p">(</span><span class="nv">fromPixelBuffer</span><span class="p">:</span> <span class="n">pixelBuffer</span><span class="p">,</span> <span class="nv">pixelFormat</span><span class="p">:</span><span class="o">.</span><span class="n">r8Unorm</span><span class="p">,</span> <span class="nv">planeIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span><span class="o">!</span>
    <span class="n">capturedImageTextureCbCr</span> <span class="o">=</span> <span class="nf">createTexture</span><span class="p">(</span><span class="nv">fromPixelBuffer</span><span class="p">:</span> <span class="n">pixelBuffer</span><span class="p">,</span> <span class="nv">pixelFormat</span><span class="p">:</span><span class="o">.</span><span class="n">rg8Unorm</span><span class="p">,</span> <span class="nv">planeIndex</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span><span class="o">!</span>
<span class="p">}</span></code></pre></figure>

<p>Next, in <strong>updateImagePlane()</strong> we update the texture coordinates of our image plane to aspect fill the viewport:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">updateImagePlane</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="kt">ARFrame</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">displayToCameraTransform</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="nf">displayTransform</span><span class="p">(</span><span class="nv">withViewportSize</span><span class="p">:</span> <span class="n">viewportSize</span><span class="p">,</span> <span class="nv">orientation</span><span class="p">:</span> <span class="o">.</span><span class="n">landscapeRight</span><span class="p">)</span><span class="o">.</span><span class="nf">inverted</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">vertexData</span> <span class="o">=</span> <span class="n">imagePlaneVertexBuffer</span><span class="o">.</span><span class="nf">contents</span><span class="p">()</span><span class="o">.</span><span class="nf">assumingMemoryBound</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">Float</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="mi">3</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">textureCoordIndex</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="k">let</span> <span class="nv">textureCoord</span> <span class="o">=</span> <span class="kt">CGPoint</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">CGFloat</span><span class="p">(</span><span class="n">planeVertexData</span><span class="p">[</span><span class="n">textureCoordIndex</span><span class="p">]),</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">CGFloat</span><span class="p">(</span><span class="n">planeVertexData</span><span class="p">[</span><span class="n">textureCoordIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">let</span> <span class="nv">transformedCoord</span> <span class="o">=</span> <span class="n">textureCoord</span><span class="o">.</span><span class="nf">applying</span><span class="p">(</span><span class="n">displayToCameraTransform</span><span class="p">)</span>
        <span class="n">vertexData</span><span class="p">[</span><span class="n">textureCoordIndex</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Float</span><span class="p">(</span><span class="n">transformedCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">vertexData</span><span class="p">[</span><span class="n">textureCoordIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Float</span><span class="p">(</span><span class="n">transformedCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Next, in <strong>drawCapturedImage()</strong> we draw the camera feed in the scene:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">drawCapturedImage</span><span class="p">(</span><span class="nv">renderEncoder</span><span class="p">:</span> <span class="kt">MTLRenderCommandEncoder</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">capturedImageTextureY</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">capturedImageTextureCbCr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">pushDebugGroup</span><span class="p">(</span><span class="s">"DrawCapturedImage"</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setCullMode</span><span class="p">(</span><span class="o">.</span><span class="k">none</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setRenderPipelineState</span><span class="p">(</span><span class="n">capturedImagePipelineState</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setDepthStencilState</span><span class="p">(</span><span class="n">capturedImageDepthState</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">imagePlaneVertexBuffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setFragmentTexture</span><span class="p">(</span><span class="n">capturedImageTextureY</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setFragmentTexture</span><span class="p">(</span><span class="n">capturedImageTextureCbCr</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">drawPrimitives</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">triangleStrip</span><span class="p">,</span> <span class="nv">vertexStart</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">vertexCount</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">popDebugGroup</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>Finally, in <strong>drawAnchorGeometry()</strong> we draw the anchors for the virtual content we created:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">drawAnchorGeometry</span><span class="p">(</span><span class="nv">renderEncoder</span><span class="p">:</span> <span class="kt">MTLRenderCommandEncoder</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">anchorInstanceCount</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">pushDebugGroup</span><span class="p">(</span><span class="s">"DrawAnchors"</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setCullMode</span><span class="p">(</span><span class="o">.</span><span class="n">back</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setRenderPipelineState</span><span class="p">(</span><span class="n">anchorPipelineState</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setDepthStencilState</span><span class="p">(</span><span class="n">anchorDepthState</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">anchorUniformBuffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="n">anchorUniformBufferOffset</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">sharedUniformBuffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="n">sharedUniformBufferOffset</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setFragmentBuffer</span><span class="p">(</span><span class="n">sharedUniformBuffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="n">sharedUniformBufferOffset</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bufferIndex</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertexBuffers</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">vertexBuffer</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertexBuffers</span><span class="p">[</span><span class="n">bufferIndex</span><span class="p">]</span>
        <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="n">vertexBuffer</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span><span class="n">bufferIndex</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">submesh</span> <span class="k">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submeshes</span> <span class="p">{</span>
        <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">drawIndexedPrimitives</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="n">submesh</span><span class="o">.</span><span class="n">primitiveType</span><span class="p">,</span> <span class="nv">indexCount</span><span class="p">:</span> <span class="n">submesh</span><span class="o">.</span><span class="n">indexCount</span><span class="p">,</span> <span class="nv">indexType</span><span class="p">:</span> <span class="n">submesh</span><span class="o">.</span><span class="n">indexType</span><span class="p">,</span> <span class="nv">indexBuffer</span><span class="p">:</span> <span class="n">submesh</span><span class="o">.</span><span class="n">indexBuffer</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="nv">indexBufferOffset</span><span class="p">:</span> <span class="n">submesh</span><span class="o">.</span><span class="n">indexBuffer</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="nv">instanceCount</span><span class="p">:</span> <span class="n">anchorInstanceCount</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">popDebugGroup</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>Back to the <strong>setupPipeline()</strong> function which we briefly mentioned earlier. We create two render pipeline state objects, one for the captured image (the camera feed) and one for the anchors we create when placing virtual objects in the scene. As expected, each of the state objects will have their own pair of vertex and fragment functions - which brings us to the last file we need to look at - the <strong>Shaders.metal</strong> file. In the first pair of shaders for the captured image, we pass through the image vertex’s position and texture coordinate in the vertex shader:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">vertex</span> <span class="kt">ImageColorInOut</span> <span class="nf">capturedImageVertexTransform</span><span class="p">(</span><span class="kt">ImageVertex</span> <span class="k">in</span> <span class="p">[[</span><span class="n">stage_in</span><span class="p">]])</span> <span class="p">{</span>
    <span class="kt">ImageColorInOut</span> <span class="n">out</span><span class="p">;</span>
    <span class="n">out</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="nf">float4</span><span class="p">(</span><span class="k">in</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="n">out</span><span class="o">.</span><span class="n">texCoord</span> <span class="o">=</span> <span class="k">in</span><span class="o">.</span><span class="n">texCoord</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>In the fragment shader we sample the two textures to get the color at the given texture coordinate after which we return the coverted <code class="highlighter-rouge">RGB</code> color:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">fragment</span> <span class="n">float4</span> <span class="nf">capturedImageFragmentShader</span><span class="p">(</span><span class="kt">ImageColorInOut</span> <span class="k">in</span> <span class="p">[[</span><span class="n">stage_in</span><span class="p">]],</span>
                                            <span class="n">texture2d</span><span class="o">&lt;</span><span class="n">float</span><span class="p">,</span> <span class="nv">access</span><span class="p">::</span><span class="n">sample</span><span class="o">&gt;</span> <span class="n">textureY</span> <span class="p">[[</span> <span class="nf">texture</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">]],</span>
                                            <span class="n">texture2d</span><span class="o">&lt;</span><span class="n">float</span><span class="p">,</span> <span class="nv">access</span><span class="p">::</span><span class="n">sample</span><span class="o">&gt;</span> <span class="n">textureCbCr</span> <span class="p">[[</span> <span class="nf">texture</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">]])</span> <span class="p">{</span>
    <span class="n">constexpr</span> <span class="n">sampler</span> <span class="nf">colorSampler</span><span class="p">(</span><span class="nv">mip_filter</span><span class="p">::</span><span class="n">linear</span><span class="p">,</span> <span class="nv">mag_filter</span><span class="p">::</span><span class="n">linear</span><span class="p">,</span> <span class="nv">min_filter</span><span class="p">::</span><span class="n">linear</span><span class="p">);</span>
    <span class="n">const</span> <span class="n">float4x4</span> <span class="n">ycbcrToRGBTransform</span> <span class="o">=</span> <span class="nf">float4x4</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="o">+</span><span class="mf">1.0000</span><span class="n">f</span><span class="p">,</span> <span class="o">+</span><span class="mf">1.0000</span><span class="n">f</span><span class="p">,</span> <span class="o">+</span><span class="mf">1.0000</span><span class="n">f</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.0000</span><span class="n">f</span><span class="p">),</span>
                                                  <span class="nf">float4</span><span class="p">(</span><span class="o">+</span><span class="mf">0.0000</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3441</span><span class="n">f</span><span class="p">,</span> <span class="o">+</span><span class="mf">1.7720</span><span class="n">f</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.0000</span><span class="n">f</span><span class="p">),</span>
                                                  <span class="nf">float4</span><span class="p">(</span><span class="o">+</span><span class="mf">1.4020</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7141</span><span class="n">f</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.0000</span><span class="n">f</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.0000</span><span class="n">f</span><span class="p">),</span>
                                                  <span class="nf">float4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.7010</span><span class="n">f</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.5291</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8860</span><span class="n">f</span><span class="p">,</span> <span class="o">+</span><span class="mf">1.0000</span><span class="n">f</span><span class="p">));</span>
    <span class="n">float4</span> <span class="n">ycbcr</span> <span class="o">=</span> <span class="nf">float4</span><span class="p">(</span><span class="n">textureY</span><span class="o">.</span><span class="nf">sample</span><span class="p">(</span><span class="n">colorSampler</span><span class="p">,</span> <span class="k">in</span><span class="o">.</span><span class="n">texCoord</span><span class="p">)</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">textureCbCr</span><span class="o">.</span><span class="nf">sample</span><span class="p">(</span><span class="n">colorSampler</span><span class="p">,</span> <span class="k">in</span><span class="o">.</span><span class="n">texCoord</span><span class="p">)</span><span class="o">.</span><span class="n">rg</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ycbcrToRGBTransform</span> <span class="o">*</span> <span class="n">ycbcr</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>In the second pair of shaders for the anchor geometry, in the vertex shader we calculate the position of our vertex in clip space and output for clipping and rasterization, then color each face a different color, then calculate the positon of our vertex in eye space and finally rotate our normals to world coordinates:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">vertex</span> <span class="kt">ColorInOut</span> <span class="nf">anchorGeometryVertexTransform</span><span class="p">(</span><span class="kt">Vertex</span> <span class="k">in</span> <span class="p">[[</span><span class="n">stage_in</span><span class="p">]],</span>
                                                <span class="n">constant</span> <span class="kt">SharedUniforms</span> <span class="o">&amp;</span><span class="n">sharedUniforms</span> <span class="p">[[</span> <span class="nf">buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">]],</span>
                                                <span class="n">constant</span> <span class="kt">InstanceUniforms</span> <span class="o">*</span><span class="n">instanceUniforms</span> <span class="p">[[</span> <span class="nf">buffer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">]],</span>
                                                <span class="n">ushort</span> <span class="n">vid</span> <span class="p">[[</span><span class="n">vertex_id</span><span class="p">]],</span>
                                                <span class="n">ushort</span> <span class="n">iid</span> <span class="p">[[</span><span class="n">instance_id</span><span class="p">]])</span> <span class="p">{</span>
    <span class="kt">ColorInOut</span> <span class="n">out</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="o">=</span> <span class="nf">float4</span><span class="p">(</span><span class="k">in</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="n">float4x4</span> <span class="n">modelMatrix</span> <span class="o">=</span> <span class="n">instanceUniforms</span><span class="p">[</span><span class="n">iid</span><span class="p">]</span><span class="o">.</span><span class="n">modelMatrix</span><span class="p">;</span>
    <span class="n">float4x4</span> <span class="n">modelViewMatrix</span> <span class="o">=</span> <span class="n">sharedUniforms</span><span class="o">.</span><span class="n">viewMatrix</span> <span class="o">*</span> <span class="n">modelMatrix</span><span class="p">;</span>
    <span class="n">out</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">sharedUniforms</span><span class="o">.</span><span class="n">projectionMatrix</span> <span class="o">*</span> <span class="n">modelViewMatrix</span> <span class="o">*</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">ushort</span> <span class="n">colorID</span> <span class="o">=</span> <span class="n">vid</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">%</span> <span class="mi">6</span><span class="p">;</span>
    <span class="n">out</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">colorID</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="nf">float4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1">// Right face</span>
              <span class="p">:</span> <span class="n">colorID</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">?</span> <span class="nf">float4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1">// Left face</span>
              <span class="p">:</span> <span class="n">colorID</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">?</span> <span class="nf">float4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1">// Top face</span>
              <span class="p">:</span> <span class="n">colorID</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">?</span> <span class="nf">float4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1">// Bottom face</span>
              <span class="p">:</span> <span class="n">colorID</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">?</span> <span class="nf">float4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1">// Back face</span>
              <span class="p">:</span>                <span class="nf">float4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// Front face</span>
    <span class="n">out</span><span class="o">.</span><span class="n">eyePosition</span> <span class="o">=</span> <span class="nf">half3</span><span class="p">((</span><span class="n">modelViewMatrix</span> <span class="o">*</span> <span class="n">position</span><span class="p">)</span><span class="o">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">float4</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">modelMatrix</span> <span class="o">*</span> <span class="nf">float4</span><span class="p">(</span><span class="k">in</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="k">in</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="k">in</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
    <span class="n">out</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="nf">half3</span><span class="p">(</span><span class="n">normal</span><span class="o">.</span><span class="n">xyz</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>In the fragment shader, we calculate the contribution of the directional light as a sum of diffuse and specular terms, then we compute the final color by multiplying the sample from the color maps by the fragment’s lighting value and finally use the color we just computed and the alpha channel of the color map for this fragment’s alpha value:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">fragment</span> <span class="n">float4</span> <span class="nf">anchorGeometryFragmentLighting</span><span class="p">(</span><span class="kt">ColorInOut</span> <span class="k">in</span> <span class="p">[[</span><span class="n">stage_in</span><span class="p">]],</span>
                                               <span class="n">constant</span> <span class="kt">SharedUniforms</span> <span class="o">&amp;</span><span class="n">uniforms</span> <span class="p">[[</span> <span class="nf">buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">]])</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">normal</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="k">in</span><span class="o">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">directionalContribution</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="n">float</span> <span class="n">nDotL</span> <span class="o">=</span> <span class="nf">saturate</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="o">-</span><span class="n">uniforms</span><span class="o">.</span><span class="n">directionalLightDirection</span><span class="p">));</span>
        <span class="n">float3</span> <span class="n">diffuseTerm</span> <span class="o">=</span> <span class="n">uniforms</span><span class="o">.</span><span class="n">directionalLightColor</span> <span class="o">*</span> <span class="n">nDotL</span><span class="p">;</span>
        <span class="n">float3</span> <span class="n">halfwayVector</span> <span class="o">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">uniforms</span><span class="o">.</span><span class="n">directionalLightDirection</span> <span class="o">-</span> <span class="nf">float3</span><span class="p">(</span><span class="k">in</span><span class="o">.</span><span class="n">eyePosition</span><span class="p">));</span>
        <span class="n">float</span> <span class="n">reflectionAngle</span> <span class="o">=</span> <span class="nf">saturate</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">halfwayVector</span><span class="p">));</span>
        <span class="n">float</span> <span class="n">specularIntensity</span> <span class="o">=</span> <span class="nf">saturate</span><span class="p">(</span><span class="nf">powr</span><span class="p">(</span><span class="n">reflectionAngle</span><span class="p">,</span> <span class="n">uniforms</span><span class="o">.</span><span class="n">materialShininess</span><span class="p">));</span>
        <span class="n">float3</span> <span class="n">specularTerm</span> <span class="o">=</span> <span class="n">uniforms</span><span class="o">.</span><span class="n">directionalLightColor</span> <span class="o">*</span> <span class="n">specularIntensity</span><span class="p">;</span>
        <span class="n">directionalContribution</span> <span class="o">=</span> <span class="n">diffuseTerm</span> <span class="o">+</span> <span class="n">specularTerm</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">float3</span> <span class="n">ambientContribution</span> <span class="o">=</span> <span class="n">uniforms</span><span class="o">.</span><span class="n">ambientLightColor</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">lightContributions</span> <span class="o">=</span> <span class="n">ambientContribution</span> <span class="o">+</span> <span class="n">directionalContribution</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="k">in</span><span class="o">.</span><span class="n">color</span><span class="o">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">lightContributions</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="k">in</span><span class="o">.</span><span class="n">color</span><span class="o">.</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>If you run the app, you should be able to tap on the screen to add cubes on top of your live camera view, and move away or closer or around the cubes to see their different colors on each face, like this:</p>

<p>￼￼<img src="https://github.com/MetalKit/images/blob/master/ARKit1.gif?raw=true" alt="alt text" title="ARKit 1" /></p>

<p>In the next part of the series we will look more into <code class="highlighter-rouge">Tracking</code> and <code class="highlighter-rouge">Scene Understanding</code> and see how plane detection, hit-testing, collisions and physics can make our experience even greater. The <a href="https://github.com/MetalKit/metal">source code</a> is posted on <code class="highlighter-rouge">Github</code> as usual.</p>

<p>Until next time!</p>

  </div>

  <!-- 
    

   -->

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style"><br />
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script>
</article>
      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper" align="center">

    <!-- <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p> -->

    <!-- Begin MailChimp Signup Form --><p>
    <link href="//cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
    <style type="text/css">
      #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
    </style>
    <div id="mc_embed_signup">
      <form action="//github.us12.list-manage.com/subscribe/post?u=5daab344aba23020915a23c29&amp;id=69e4a7c3af" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
          <div id="mc_embed_signup_scroll">
        <label for="mce-EMAIL">Subscribe to be notified of new posts.</label>
        <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
          <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_5daab344aba23020915a23c29_69e4a7c3af" tabindex="-1" value=""></div>
          <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
          </div>
      </form>
    </div>
    </p><!--End mc_embed_signup-->

    <!-- <h2 class="footer-heading">The Metal Framework</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p>
        <ul class="contact-list">
          <li>
            
              The Metal Framework
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/MetalKit"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">MetalKit</span></a>

          </li>
          
          
          <li>
            <a href="https://twitter.com/gpu3d"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">gpu3d</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        
          <a href="https://twitter.com/gpu3d"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">gpu3d</span></a>

        
        <p>Resources and tutorials for Metal, MetalKit and Metal Performance Shaders.
</p>
      </div>
    </div> -->

  </div>

</footer>


  </body>

</html>
