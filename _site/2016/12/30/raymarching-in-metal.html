<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Raymarching in Metal</title>
  <meta name="description" content="Raymarching is a fast rendering method used in realtime graphics. The geometry is usually not passed to the renderer but rather created in the shader using S...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" href="https://devimages.apple.com.edgekey.net/assets/elements/icons/metal/metal-128x128_2x.png" />
  <link rel="canonical" href="http://localhost:4000/2016/12/30/raymarching-in-metal.html">
  <link rel="alternate" type="application/rss+xml" title="The Metal Framework" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">The Metal Framework</a>

    <nav class="site-nav">
    
    <!--
      <a href="/archive.html" style="color:grey;">Archives</a>&nbsp;&nbsp;&nbsp;
    -->
    
      <a href="/contact.html" style="color:grey;">Contact</a>&nbsp;&nbsp;&nbsp;
      <a href="/feed.xml" style="color:grey;">RSS</a>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Raymarching in Metal</h1>
    <p class="post-meta"><time datetime="2016-12-30T00:00:00-06:00" itemprop="datePublished">Dec 30, 2016</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by <a href = "https://twitter.com/gpu3d" target="_blank">Marius Horga</a></span></span></p>
  </header>

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script><br /><br />

  <div class="post-content" itemprop="articleBody">
    <p><strong>Raymarching</strong> is a fast rendering method used in realtime graphics. The geometry is usually not passed to the renderer but rather created in the shader using <strong>Signed Distance Fields (SDF)</strong> functions that describe the shortest distance between a point and the surface of any object in the scene. The <code class="highlighter-rouge">SDF</code> returns a negative number if the point is inside of an object. Also, <code class="highlighter-rouge">SDFs</code> are useful because they allow us to reduce the number of samples used by <code class="highlighter-rouge">Ray Tracing</code>.  Similar to <em>Ray Tracing</em>, in <code class="highlighter-rouge">Raymarching</code> we also have a ray cast for each pixel on the view plane and each ray is used to determine if there is an intersection with an object.</p>

<p>The difference between the two techniques is that in <em>Ray Tracing</em> the intersection is determined by a strict set of equations while in <code class="highlighter-rouge">Raymarching</code> the intersection is approximated. Using <code class="highlighter-rouge">SDFs</code> we can <em>march</em> along the ray until we get close enough to an object. This is inexpensive to compute compared to exactly determining intersections which could become very expensive when there are many objects in the scene and the lighting is complex. Another great use case for <code class="highlighter-rouge">Raymarching</code> is volumetric rendering (fog, water, clouds) which <em>Ray Tracing</em> cannot easily do because determining intersections with such volumes is quite difficult.</p>

<p>To follow along, you can use the playground from <a href="http://metalkit.org/2016/05/02/using-metalkit-part-10.html">Using MetalKit part 10</a>, slightly modified as explained next. Let’s start with two basic building blocks we need at the very minimum in our kernel: a ray and an object (sphere).</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">Ray</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">origin</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">direction</span><span class="p">;</span>
    <span class="kt">Ray</span><span class="p">(</span><span class="n">float3</span> <span class="n">o</span><span class="p">,</span> <span class="n">float3</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">struct</span> <span class="kt">Sphere</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">center</span><span class="p">;</span>
    <span class="n">float</span> <span class="n">radius</span><span class="p">;</span>
    <span class="kt">Sphere</span><span class="p">(</span><span class="n">float3</span> <span class="n">c</span><span class="p">,</span> <span class="n">float</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>As we did back in <em>part 10</em>, let’s also write a <code class="highlighter-rouge">SDF</code> for calculating the distance from a given point to the sphere. The difference from the old function is that now our point is <em>marching</em> along the ray, so we use the ray position instead:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float</span> <span class="nf">distToSphere</span><span class="p">(</span><span class="kt">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">Sphere</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">length</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">center</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">radius</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>All we had to do back then was to calculate the distance from any given point to a circle (not a sphere because we did not have <code class="highlighter-rouge">3D</code> back then) like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float</span> <span class="nf">dist</span><span class="p">(</span><span class="n">float2</span> <span class="n">point</span><span class="p">,</span> <span class="n">float2</span> <span class="n">center</span><span class="p">,</span> <span class="n">float</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">length</span><span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span> <span class="o">-</span> <span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">...</span>
<span class="n">float</span> <span class="n">distToCircle</span> <span class="o">=</span> <span class="nf">dist</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="nf">float2</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">inside</span> <span class="o">=</span> <span class="n">distToCircle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">;</span>
<span class="n">output</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="n">inside</span> <span class="p">?</span> <span class="nf">float4</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="p">:</span> <span class="nf">float4</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="p">),</span> <span class="n">gid</span><span class="p">);</span>
<span class="o">...</span></code></pre></figure>

<p>We now need to have a ray and march along with it through the scene, so replace those last three lines in the kernel with the following lines:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">Sphere</span> <span class="n">s</span> <span class="o">=</span> <span class="kt">Sphere</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="p">),</span> <span class="mi">1</span><span class="o">.</span><span class="p">);</span>
<span class="kt">Ray</span> <span class="n">ray</span> <span class="o">=</span> <span class="kt">Ray</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="p">,</span> <span class="mi">0</span><span class="o">.</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">.</span><span class="p">),</span> <span class="nf">normalize</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)));</span>
<span class="n">float3</span> <span class="n">col</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="o">.</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="nf">distToSphere</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">col</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">+=</span> <span class="n">ray</span><span class="o">.</span><span class="n">direction</span> <span class="o">*</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">1</span><span class="o">.</span><span class="p">),</span> <span class="n">gid</span><span class="p">);</span></code></pre></figure>

<p>Let’s go over the code line by line. We first create a sphere object and a ray. Notice that as ray’s <code class="highlighter-rouge">z</code> value approaches <code class="highlighter-rouge">0</code>, the sphere seems bigger because the ray is closer to the scene, and vice versa, when it goes away from <code class="highlighter-rouge">0</code>, the sphere seems smaller for the obvious reason – we use our ray as our implicit <code class="highlighter-rouge">camera</code>. Next we define the color to be initially a solid black. Now comes the very essence of <code class="highlighter-rouge">raymarching</code>! We loop for a given number of times (steps) to make sure we get enough precision. We go with <code class="highlighter-rouge">100</code> in this case but you can try with a bigger number of steps and see how the quality of the rendered image improves, at the expense of more computing resources used, however. Inside the loop we calculate the distance from our current position along the ray to the scene, while also checking if we reached an object in the scene, and if we did, we color it in solid white and break out of this particular iteration, or otherwise update the ray position by moving it closer to the scene.</p>

<p>Notice that we normalized the ray direction to cover edge cases where for example the length of the vector <code class="highlighter-rouge">(1, 1, 1)</code> (corner of the screen) would have a value of <code class="highlighter-rouge">sqrt(1 * 1 + 1 * 1 + 1 * 1)</code> which approximates to <code class="highlighter-rouge">1.73</code>. That means we would need to move the ray position forward by <code class="highlighter-rouge">1.73 * dist</code> which is almost double the distance we need to move forward, thus making us miss the object by overshooting the ray beyond the intersection point. For that reason, we normalize the direction, to make sure its length will always be <code class="highlighter-rouge">1</code>. Finally, we write the color to the output texture. If you run the playground now you should see a similar image:</p>

<p><img src="https://github.com/MetalKit/images/raw/master/raymarching1.png" alt="alt text" title="1" /></p>

<p>Now let’s create a function named <strong>distToScene</strong> that only takes a ray in as argument because all we care now is to find the shortest distance to a complex scene that contains multiple objects. Next, we move the code related to the sphere inside this new function where we return only the distance to the sphere (for now). Then, we change the sphere position to <code class="highlighter-rouge">(1, 1, 1)</code> and its radius to <code class="highlighter-rouge">0.5</code> which means the sphere is now in the <code class="highlighter-rouge">0.5 ... 1.5</code> range. Here comes a neat trick to do instancing: if we repeat the space between <code class="highlighter-rouge">0.0 ... 2.0</code>, the sphere is safely inside. Next, we make a local copy of the ray and modulus its origin. Then we use the repeating ray with the <code class="highlighter-rouge">distToSphere()</code> function.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float</span> <span class="nf">distToScene</span><span class="p">(</span><span class="kt">Ray</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">Sphere</span> <span class="n">s</span> <span class="o">=</span> <span class="kt">Sphere</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">);</span>
    <span class="kt">Ray</span> <span class="n">repeatRay</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
    <span class="n">repeatRay</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="nf">fmod</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">distToSphere</span><span class="p">(</span><span class="n">repeatRay</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>By using the <code class="highlighter-rouge">fmod</code> function we repeated the space throughout the entire screen and pratically created an infinite number of spheres, each with its own (repeated) ray. Of course, we will only see the ones bounded by the <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> coordinates of the screen, however, the <code class="highlighter-rouge">z</code> coordinate will let us see how the spheres go indefinitely in depth. Inside the kernel, remove the sphere line, move the ray to a really far location, modify <code class="highlighter-rouge">dist</code> to rather give us the distance to the scene, and finally change the last line to give us some nice colors:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">Ray</span> <span class="n">ray</span> <span class="o">=</span> <span class="kt">Ray</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="mi">1000</span><span class="o">.</span><span class="p">),</span> <span class="nf">normalize</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)));</span>
<span class="o">...</span>
<span class="n">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="nf">distToScene</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">output</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="nf">abs</span><span class="p">((</span><span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="mi">1000</span><span class="o">.</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">),</span> <span class="mi">1</span><span class="o">.</span><span class="p">),</span> <span class="n">gid</span><span class="p">);</span></code></pre></figure>

<p>We are multiplying the color by the ray position. We divide by <code class="highlighter-rouge">10.0</code> because the scene is quite big and the ray position is bigger than <code class="highlighter-rouge">1.0</code> in most places, which would give us a solid white. We use <code class="highlighter-rouge">abs()</code> because on the left side of the screen <code class="highlighter-rouge">x</code> is lower than <code class="highlighter-rouge">0</code> which would give us a solid black so we basically mirror the top/bottom and left/right colors. Finally, we offset the ray position by <code class="highlighter-rouge">1000</code> to match the ray origin (camera) we set. If you run the playground now you should see a similar image:</p>

<p><img src="https://github.com/MetalKit/images/raw/master/raymarching2.png" alt="alt text" title="2" /></p>

<p>Next, let’s animate the scene! We have seen in <a href="http://metalkit.org/2016/05/18/using-metalkit-part-12.html">part 12</a> how to send useful <em>uniforms</em> to the <code class="highlighter-rouge">GPU</code>, such as the <code class="highlighter-rouge">time</code> so we are not going to discuss about how to implement that again here.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">float3</span> <span class="n">camPos</span> <span class="o">=</span> <span class="nf">float3</span><span class="p">(</span><span class="mi">1000</span><span class="o">.</span> <span class="o">+</span> <span class="nf">sin</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">.</span><span class="p">,</span> <span class="mi">1000</span><span class="o">.</span> <span class="o">+</span> <span class="nf">cos</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">.</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
<span class="kt">Ray</span> <span class="n">ray</span> <span class="o">=</span> <span class="kt">Ray</span><span class="p">(</span><span class="n">camPos</span><span class="p">,</span> <span class="nf">normalize</span><span class="p">(</span><span class="nf">float3</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">1</span><span class="o">.</span><span class="p">)));</span>
<span class="o">...</span>
<span class="n">float3</span> <span class="n">posRelativeToCamera</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">camPos</span><span class="p">;</span>
<span class="n">output</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">float4</span><span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="nf">abs</span><span class="p">((</span><span class="n">posRelativeToCamera</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">),</span> <span class="mi">1</span><span class="o">.</span><span class="p">),</span> <span class="n">gid</span><span class="p">);</span></code></pre></figure>

<p>We added <code class="highlighter-rouge">time</code> to all three coordinates, but we only fluctuate the <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> while keeping <code class="highlighter-rouge">z</code> a straight line. The <code class="highlighter-rouge">1.</code> part is there just to stop the camera crashing into the nearest sphere. To see an animated version of this code, I used a <code class="highlighter-rouge">Shadertoy</code> embedded player below. Just hover over it and click the play button to watch it in action:</p>

<iframe width="740" height="450" frameborder="0" src="https://www.shadertoy.com/embed/XtcSDf" allowfullscreen=""></iframe>
<p><br /></p>

<p>I want to thanks <a href="https://twitter.com/_psonice">Chris</a> again for his assistance. The <a href="https://github.com/MetalKit/metal">source code</a> is posted on <code class="highlighter-rouge">Github</code> as usual.</p>

<p>Until next time!</p>

  </div>

  <!-- 
    

   -->

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style"><br />
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script>
</article>
      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper" align="center">

    <!-- <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p> -->

    <!-- Begin MailChimp Signup Form --><p>
    <link href="//cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
    <style type="text/css">
      #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
    </style>
    <div id="mc_embed_signup">
      <form action="//github.us12.list-manage.com/subscribe/post?u=5daab344aba23020915a23c29&amp;id=69e4a7c3af" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
          <div id="mc_embed_signup_scroll">
        <label for="mce-EMAIL">Subscribe to be notified of new posts.</label>
        <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
          <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_5daab344aba23020915a23c29_69e4a7c3af" tabindex="-1" value=""></div>
          <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
          </div>
      </form>
    </div>
    </p><!--End mc_embed_signup-->

    <!-- <h2 class="footer-heading">The Metal Framework</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p>
        <ul class="contact-list">
          <li>
            
              The Metal Framework
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/MetalKit"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">MetalKit</span></a>

          </li>
          
          
          <li>
            <a href="https://twitter.com/gpu3d"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">gpu3d</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        
          <a href="https://twitter.com/gpu3d"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">gpu3d</span></a>

        
        <p>Resources and tutorials for Metal, MetalKit and Metal Performance Shaders.
</p>
      </div>
    </div> -->

  </div>

</footer>


  </body>

</html>
