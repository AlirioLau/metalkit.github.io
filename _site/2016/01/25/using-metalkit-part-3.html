<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Using MetalKit part 3</title>
  <meta name="description" content="In the previous part I promised we will learn more about the Metal shading language. Before that, first let’s do some code cleaning and structuring since we ...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" href="https://devimages.apple.com.edgekey.net/assets/elements/icons/metal/metal-128x128_2x.png" />
  <link rel="canonical" href="http://localhost:4000/2016/01/25/using-metalkit-part-3.html">
  <link rel="alternate" type="application/rss+xml" title="The Metal Framework" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">The Metal Framework</a>

    <nav class="site-nav">
      <a href="/archive.html">Archives</a>&nbsp;&nbsp;&nbsp;
      <a href="/contact.html">Contact</a>&nbsp;&nbsp;&nbsp;
      <a href="/feed.xml">RSS</a>

      <!-- <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/archive.html">Archives</a>
          
        
          
          <a class="page-link" href="/contact.html">Contact me</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/sent.html">Sent</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div> -->
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Using MetalKit part 3</h1>
    <p class="post-meta"><time datetime="2016-01-25T00:00:00+02:00" itemprop="datePublished">Jan 25, 2016</time></p>
  </header>

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script><br /><br />

  <div class="post-content" itemprop="articleBody">
    <p>In the previous part I promised we will learn more about the <code class="highlighter-rouge">Metal shading language</code>. Before that, first let’s do some code cleaning and structuring since we are already getting into the habit of doing this from previous episodes. Start by downloading the <a href="https://github.com/MetalKit/metal">source code</a> from the previous episode. We want to refactor the huge <strong>render()</strong> function, to start with. So let’s take the <em>vertex buffer</em> and the <em>render pipeline state</em> outside of the function, and also create <strong>3</strong> new smaller functions, so that our old function reduces to this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="k">var</span> <span class="nv">vertex_buffer</span><span class="p">:</span> <span class="kt">MTLBuffer</span><span class="o">!</span>
<span class="k">var</span> <span class="nv">rps</span><span class="p">:</span> <span class="kt">MTLRenderPipelineState</span><span class="o">!</span> <span class="o">=</span> <span class="kc">nil</span>

<span class="kd">func</span> <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">device</span> <span class="o">=</span> <span class="kt">MTLCreateSystemDefaultDevice</span><span class="p">()</span>
    <span class="nf">createBuffer</span><span class="p">()</span>
    <span class="nf">registerShaders</span><span class="p">()</span>
    <span class="nf">sendToGPU</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>For the <strong>createBuffer()</strong> function we need to first make some changes. Recall from last episode that <em>vertex data</em> was an array of type <code class="highlighter-rouge">Float</code> like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="k">let</span> <span class="nv">vertex_data</span><span class="p">:[</span><span class="kt">Float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span></code></pre></figure>

<p>Let’s transform it into a better suited format, a <strong>struct</strong> with two members of <code class="highlighter-rouge">vector_float4</code> type, one for <strong>position</strong> and the other for <strong>color</strong>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="kd">struct</span> <span class="kt">Vertex</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">position</span><span class="p">:</span> <span class="n">vector_float4</span>
    <span class="k">var</span> <span class="nv">color</span><span class="p">:</span> <span class="n">vector_float4</span>
<span class="p">}</span></code></pre></figure>

<p>You might wonder what kind of a data type <strong>vector_float4</strong> is. From <code class="highlighter-rouge">Apple</code>’s documentation we find that the vector types are clang-based types that are better suited than traditional <code class="highlighter-rouge">SIMD</code> types for vector-vector and vector-scalar arithmetic operations. It is possible to access vector components both via array-style subscripting, and by using the <strong>.</strong> operator with component names (<code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code>, <code class="highlighter-rouge">z</code>, <code class="highlighter-rouge">w</code>, or combinations thereof). Besides the <strong>.xyzw</strong> component names, the following sub-vectors can also be easily accessed: <strong>.lo</strong> / <strong>.hi</strong> (first half and second half of a vector), as well as the <strong>.even</strong> / <strong>.odd</strong> sub-vectors:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="n">vector_float4</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>         <span class="c1">// x = { 1, 1, 1, 1 }.
</span>
<span class="n">vector_float3</span> <span class="n">y</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>  <span class="c1">// y = { 1, 2, 3 }.
</span>
<span class="n">x</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">zyx</span><span class="p">;</span>                  <span class="c1">// x = { 1/3, 1/2, 1, 1 }.
</span>
<span class="n">x</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                        <span class="c1">// x = { 1/4, 1/3, 1/2, 0 }.</span></code></pre></figure>

<p>Let’s get back to <code class="highlighter-rouge">createBuffer()</code> so we can change our <strong>vertex_data</strong> using the new <code class="highlighter-rouge">struct</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="kd">func</span> <span class="nf">createBuffer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">vertex_data</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Vertex</span><span class="p">(</span><span class="nv">position</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nv">color</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                       <span class="kt">Vertex</span><span class="p">(</span><span class="nv">position</span><span class="p">:</span> <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nv">color</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                       <span class="kt">Vertex</span><span class="p">(</span><span class="nv">position</span><span class="p">:</span> <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nv">color</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span>
    <span class="n">vertex_buffer</span> <span class="o">=</span> <span class="n">device</span><span class="o">!.</span><span class="nf">newBufferWithBytes</span><span class="p">(</span><span class="n">vertex_data</span><span class="p">,</span> <span class="nv">length</span><span class="p">:</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">Vertex</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="nv">options</span><span class="p">:[])</span>
<span class="p">}</span></code></pre></figure>

<p>You notice how handy is to have it as an array of structs where we can easily create vertexes in place. You also notice we kept the vertex positions as they were last time, and we added separate colors for each vertex (red, green and blue). Next up, is the <strong>registerShaders()</strong> function. We don’t change anything to the old code other than having it moved to this new place:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="kd">func</span> <span class="nf">registerShaders</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">library</span> <span class="o">=</span> <span class="n">device</span><span class="o">!.</span><span class="nf">newDefaultLibrary</span><span class="p">()</span><span class="o">!</span>
    <span class="k">let</span> <span class="nv">vertex_func</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="nf">newFunctionWithName</span><span class="p">(</span><span class="s">"vertex_func"</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">frag_func</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="nf">newFunctionWithName</span><span class="p">(</span><span class="s">"fragment_func"</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">rpld</span> <span class="o">=</span> <span class="kt">MTLRenderPipelineDescriptor</span><span class="p">()</span>
    <span class="n">rpld</span><span class="o">.</span><span class="n">vertexFunction</span> <span class="o">=</span> <span class="n">vertex_func</span>
    <span class="n">rpld</span><span class="o">.</span><span class="n">fragmentFunction</span> <span class="o">=</span> <span class="n">frag_func</span>
    <span class="n">rpld</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelFormat</span> <span class="o">=</span> <span class="o">.</span><span class="kt">BGRA8Unorm</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="k">try</span> <span class="n">rps</span> <span class="o">=</span> <span class="n">device</span><span class="o">!.</span><span class="nf">newRenderPipelineStateWithDescriptor</span><span class="p">(</span><span class="n">rpld</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="k">let</span> <span class="nv">error</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And lastly, we do the same with the <strong>sendToGPU()</strong> function, nothing being changed to the old code other than having it moved to this new place:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="kd">func</span> <span class="nf">sendToGPU</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">rpd</span> <span class="o">=</span> <span class="n">currentRenderPassDescriptor</span><span class="p">,</span> <span class="n">drawable</span> <span class="o">=</span> <span class="n">currentDrawable</span> <span class="p">{</span>
        <span class="n">rpd</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clearColor</span> <span class="o">=</span> <span class="kt">MTLClearColorMake</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">command_buffer</span> <span class="o">=</span> <span class="n">device</span><span class="o">!.</span><span class="nf">newCommandQueue</span><span class="p">()</span><span class="o">.</span><span class="nf">commandBuffer</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">command_encoder</span> <span class="o">=</span> <span class="n">command_buffer</span><span class="o">.</span><span class="nf">renderCommandEncoderWithDescriptor</span><span class="p">(</span><span class="n">rpd</span><span class="p">)</span>
        <span class="n">command_encoder</span><span class="o">.</span><span class="nf">setRenderPipelineState</span><span class="p">(</span><span class="n">rps</span><span class="p">)</span>
        <span class="n">command_encoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">vertex_buffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">atIndex</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">command_encoder</span><span class="o">.</span><span class="nf">drawPrimitives</span><span class="p">(</span><span class="o">.</span><span class="kt">Triangle</span><span class="p">,</span> <span class="nv">vertexStart</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">vertexCount</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nv">instanceCount</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">command_encoder</span><span class="o">.</span><span class="nf">endEncoding</span><span class="p">()</span>
        <span class="n">command_buffer</span><span class="o">.</span><span class="nf">presentDrawable</span><span class="p">(</span><span class="n">drawable</span><span class="p">)</span>
        <span class="n">command_buffer</span><span class="o">.</span><span class="nf">commit</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s move on to the <strong>Shaders.metal</strong> file next. We do two modifications here. First, we add a <strong>color</strong> member to our <code class="highlighter-rouge">Vertex</code> struct so we can pass it back and forth between the <code class="highlighter-rouge">CPU</code> and the <code class="highlighter-rouge">GPU</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="kd">struct</span> <span class="kt">Vertex</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="p">[[</span><span class="n">position</span><span class="p">]];</span>
    <span class="n">float4</span> <span class="n">color</span><span class="p">;</span> 
<span class="p">};</span></code></pre></figure>

<p>Second, we replace the hardcoded color we used last time in the <strong>fragment</strong> shader:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="n">fragment</span> <span class="n">float4</span> <span class="nf">fragment_func</span><span class="p">(</span><span class="kt">Vertex</span> <span class="n">vert</span> <span class="p">[[</span><span class="n">stage_in</span><span class="p">]])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>with the actual color each vertex carries (sent to <code class="highlighter-rouge">GPU</code> by the <strong>vertex_buffer</strong>):</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="n">fragment</span> <span class="n">float4</span> <span class="nf">fragment_func</span><span class="p">(</span><span class="kt">Vertex</span> <span class="n">vert</span> <span class="p">[[</span><span class="n">stage_in</span><span class="p">]])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">vert</span><span class="o">.</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>If you run the app, you should now see a more nicely colored triangle:</p>

<p><img src="https://github.com/MetalKit/images/blob/master/chapter04.png?raw=true" alt="alt text" title="1" />
You might be wondering why are the colors becoming gradients as we move away from the three vertexes we passed to the shaders? To understand this, it’s important to first understand the difference between the two shaders and their role in the graphics pipeline. Let’s look at the syntax for writing any shader (we choose the vertex shader as example):</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="n">vertex</span> <span class="kt">Vertex</span> <span class="nf">vertex_func</span><span class="p">(</span><span class="n">constant</span> <span class="kt">Vertex</span> <span class="o">*</span><span class="n">vertices</span> <span class="p">[[</span><span class="nf">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)]],</span> <span class="n">uint</span> <span class="n">vid</span> <span class="p">[[</span><span class="n">vertex_id</span><span class="p">]])</span></code></pre></figure>

<p>The first keyword is the function <strong>qualifier</strong> and can only have the value <strong>vertex</strong>, <strong>fragment</strong> or <strong>kernel</strong>. The next keyword is the <strong>return type</strong>. Next is the function <strong>name</strong> followed by the function <strong>arguments</strong> inside the parentheses. The <code class="highlighter-rouge">Metal shading language</code> restricts the use of pointers unless the arguments are declared with the <strong>device</strong>, <strong>threadgroup</strong>, or <strong>constant</strong> address space qualifier which specifies the region of memory where a function variable or argument is allocated. The <strong>[[ … ]]</strong> syntax is used to declare attributes such as resource locations, shader inputs, and built-in variables that are passed back and forth between shaders and CPU.</p>

<p><code class="highlighter-rouge">Metal</code> uses the <strong>[[ buffer(index) ]]</strong> attribute to identify the location for the <code class="highlighter-rouge">device</code> and <code class="highlighter-rouge">constant buffer</code> argument types. Built-in input and output variables are used to communicate values between the graphics (vertex and fragment) functions and the fixed-function graphics pipeline stages. In our case <strong>[[ vertex_id ]]</strong> is the per-vertex identifier used in communication. <code class="highlighter-rouge">Metal</code> generates the per-fragment inputs to a fragment function using the output from a vertex function and the fragments generated by the rasterizer. The per-fragment inputs are identified with the <strong>[[ stage_in ]]</strong> attribute qualifier.</p>

<p>The <code class="highlighter-rouge">vertex shader</code> takes a pointer to the vertex list as the 1st parameter. We will be able to index into <strong>vertices</strong> using the 2nd parameter <strong>vid</strong> which is attributed with <strong>vertex_id</strong> that tells <code class="highlighter-rouge">Metal</code> to insert the vertex index currently being processed as this parameter. We then simply pass along each vertex (with its position and color) for the <code class="highlighter-rouge">fragment shader</code> to consume. All the <code class="highlighter-rouge">fragment shader</code> does is to take the vertex passed from the <code class="highlighter-rouge">vertex shader</code> and pass through the color for each and every pixel without changing anything to the input data. The vertex shader runs infrequently (only 3 times in this case - for each vertex), while the <code class="highlighter-rouge">fragment shader</code> runs thousands of times - for each pixel it needs to draw.</p>

<p>So you might be still asking: “Ok, but what about the color gradients”? Well, now that you understand what each shader does and how often they run, you can think about the color at any given pixel as the <strong>average</strong> color value of its neighbors. For example, the color halfway between the the <code class="highlighter-rouge">red</code> and the <code class="highlighter-rouge">green</code> pixel will be <code class="highlighter-rouge">yellow</code> simply because the <code class="highlighter-rouge">fragment shader</code> interpolates the two colors by averaging them: <strong>0.5 * red + 0.5 * green</strong>. The same happens with the color halfway between <code class="highlighter-rouge">red</code> and <code class="highlighter-rouge">blue</code> resulting <code class="highlighter-rouge">magenta</code>, as well as halfway between <code class="highlighter-rouge">blue</code> and <code class="highlighter-rouge">green</code> resulting <code class="highlighter-rouge">cyan</code>. From here on, the rest of the pixels are interpolated with unequal parts of the primary colors resulting the gradient range you see.</p>

<p>The <a href="https://github.com/MetalKit/metal">source code</a> is posted on Github as usual.</p>

<p>Until next time!</p>

  </div>

  <!-- 
    

   -->

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style"><br />
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script>
</article>
      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper" align="center">

    <!-- <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p> -->

    <!-- Begin MailChimp Signup Form --><p>
    <link href="//cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
    <style type="text/css">
      #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
    </style>
    <div id="mc_embed_signup">
      <form action="//github.us12.list-manage.com/subscribe/post?u=5daab344aba23020915a23c29&amp;id=69e4a7c3af" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
          <div id="mc_embed_signup_scroll">
        <label for="mce-EMAIL">Subscribe to be notified of new posts.</label>
        <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
          <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_5daab344aba23020915a23c29_69e4a7c3af" tabindex="-1" value=""></div>
          <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
          </div>
      </form>
    </div>
    </p><!--End mc_embed_signup-->

    <!-- <h2 class="footer-heading">The Metal Framework</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p>
        <ul class="contact-list">
          <li>
            
              The Metal Framework
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/MetalKit"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">MetalKit</span></a>

          </li>
          
          
          <li>
            <a href="https://twitter.com/MTLDevice"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">MTLDevice</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        
          <a href="https://twitter.com/MTLDevice"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">MTLDevice</span></a>

        
        <p>Resources and tutorials for Metal, MetalKit and Metal Performance Shaders.
</p>
      </div>
    </div> -->

  </div>

</footer>


  </body>

</html>
