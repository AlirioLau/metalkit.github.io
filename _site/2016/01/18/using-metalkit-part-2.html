<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Using MetalKit part 2</title>
  <meta name="description" content="In the first part of this series we introduced the MetalKit framework. Let’s reuse the project from part 1 and pick up where we left off. If you look again a...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" href="https://devimages.apple.com.edgekey.net/assets/elements/icons/metal/metal-128x128_2x.png" />
  <link rel="canonical" href="http://localhost:4000/2016/01/18/using-metalkit-part-2.html">
  <link rel="alternate" type="application/rss+xml" title="The Metal Framework" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">The Metal Framework</a>

    <nav class="site-nav">
    
    <!--
      <a href="/archive.html" style="color:grey;">Archives</a>&nbsp;&nbsp;&nbsp;
    -->
    
      <a href="/contact.html" style="color:grey;">Contact</a>&nbsp;&nbsp;&nbsp;
      <a href="/feed.xml" style="color:grey;">RSS</a>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Using MetalKit part 2</h1>
    <p class="post-meta"><time datetime="2016-01-18T00:00:00-06:00" itemprop="datePublished">Jan 18, 2016</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name"><a href = "https://twitter.com/gpu3d" target="_blank">Marius Horga</a></span></span></p>
  </header>

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script><br /><br />

  <div class="post-content" itemprop="articleBody">
    <p>In the first part of this series we introduced the MetalKit framework. Let’s reuse the project from <code class="highlighter-rouge">part 1</code> and pick up where we left off. If you look again at the <strong>render()</strong> function, it was looking like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="kd">func</span> <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">device</span> <span class="o">=</span> <span class="kt">MTLCreateSystemDefaultDevice</span><span class="p">()</span><span class="o">!</span>
    <span class="k">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
    <span class="k">let</span> <span class="nv">rpd</span> <span class="o">=</span> <span class="kt">MTLRenderPassDescriptor</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">bleen</span> <span class="o">=</span> <span class="kt">MTLClearColor</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">rpd</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">texture</span> <span class="o">=</span> <span class="n">currentDrawable</span><span class="o">!.</span><span class="n">texture</span>
    <span class="n">rpd</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clearColor</span> <span class="o">=</span> <span class="n">bleen</span>
    <span class="n">rpd</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">loadAction</span> <span class="o">=</span> <span class="o">.</span><span class="kt">Clear</span>
    <span class="k">let</span> <span class="nv">commandQueue</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">newCommandQueue</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">commandBuffer</span> <span class="o">=</span> <span class="n">commandQueue</span><span class="o">.</span><span class="nf">commandBuffer</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">encoder</span> <span class="o">=</span> <span class="n">commandBuffer</span><span class="o">.</span><span class="nf">renderCommandEncoderWithDescriptor</span><span class="p">(</span><span class="n">rpd</span><span class="p">)</span>
    <span class="n">encoder</span><span class="o">.</span><span class="nf">endEncoding</span><span class="p">()</span>
    <span class="n">commandBuffer</span><span class="o">.</span><span class="nf">presentDrawable</span><span class="p">(</span><span class="n">currentDrawable</span><span class="o">!</span><span class="p">)</span>
    <span class="n">commandBuffer</span><span class="o">.</span><span class="nf">commit</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s improve this code a bit. First, since our class subclasses <strong>MTKView</strong>, it already has its own <code class="highlighter-rouge">device</code> so there is no need to declare another one. This lets us reduce the first two lines to just one:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="n">device</span> <span class="o">=</span> <span class="kt">MTLCreateSystemDefaultDevice</span><span class="p">()</span></code></pre></figure>

<p>Second, last week we said that we should make sure <strong>currentDrawable</strong> and <strong>currentRenderPassDescriptor</strong> are not nil or the app will crash. For the sake of simplicity, we have not done that in part one, so let’s do that now. This will also help us get rid of a couple more lines of code. The final version of the function will look like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="kd">func</span> <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">device</span> <span class="o">=</span> <span class="kt">MTLCreateSystemDefaultDevice</span><span class="p">()</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">rpd</span> <span class="o">=</span> <span class="n">currentRenderPassDescriptor</span><span class="p">,</span> <span class="n">drawable</span> <span class="o">=</span> <span class="n">currentDrawable</span> <span class="p">{</span>
        <span class="n">rpd</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clearColor</span> <span class="o">=</span> <span class="kt">MTLClearColorMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">command_buffer</span> <span class="o">=</span> <span class="n">device</span><span class="o">!.</span><span class="nf">newCommandQueue</span><span class="p">()</span><span class="o">.</span><span class="nf">commandBuffer</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">command_encoder</span> <span class="o">=</span> <span class="n">command_buffer</span><span class="o">.</span><span class="nf">renderCommandEncoderWithDescriptor</span><span class="p">(</span><span class="n">rpd</span><span class="p">)</span>
        <span class="n">command_encoder</span><span class="o">.</span><span class="nf">endEncoding</span><span class="p">()</span>
        <span class="n">command_buffer</span><span class="o">.</span><span class="nf">presentDrawable</span><span class="p">(</span><span class="n">drawable</span><span class="p">)</span>
        <span class="n">command_buffer</span><span class="o">.</span><span class="nf">commit</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>You might wonder what <strong>colorAttachments[0]</strong> means. To set the <code class="highlighter-rouge">rendering pipeline state</code>, the <code class="highlighter-rouge">Metal</code> framework provides <strong>3</strong> types of attachments that we can write to:</p>

<ul>
  <li>colorAttachments</li>
  <li>depthAttachmentPixelFormat</li>
  <li>stencilAttachmentPixelFormat</li>
</ul>

<p>We are only interested in storing color data for now and <code class="highlighter-rouge">colorAttachments</code> is an array of textures that hold drawings results and display them on the screen. We currently only have one such texture - the first element (at index <code class="highlighter-rouge">0</code>) of the array. Ok, now is a good time to run the app and make sure you are still seeing the same colored background we saw last time. So much better! With only <strong>9</strong> lines of code we can get safe <code class="highlighter-rouge">Metal</code> code running on our GPU. Not too shabby.</p>

<p>So far so good! Next, let’s dive into a new <code class="highlighter-rouge">Metal</code> topic - drawing geometry on the screen. All graphics tutorials such as those about <code class="highlighter-rouge">OpenGL</code> start with a <code class="highlighter-rouge">Hello, Triangle</code> type of program because a triangle is the simplest form of geometry that can be drawn on screen. It is a <strong>2D graphics</strong> basic element and all the other objects in the world of graphics are composed of triangles, so this makes it a great place to start. Imagine the screen coordinate system having its axes running through the center of the screen which would have the coordinates <strong>(0, 0)</strong>. The edges of the screen would have values of <strong>-1</strong> and <strong>1</strong> respectively. Let’s create an array of floats and a buffer to hold the vertex values for our triangle. Insert these lines right after initializing the <code class="highlighter-rouge">device</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="k">let</span> <span class="nv">vertex_data</span><span class="p">:[</span><span class="kt">Float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">data_size</span> <span class="o">=</span> <span class="n">vertex_data</span><span class="o">.</span><span class="n">count</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">Float</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">vertex_buffer</span> <span class="o">=</span> <span class="n">device</span><span class="o">!.</span><span class="nf">newBufferWithBytes</span><span class="p">(</span><span class="n">vertex_data</span><span class="p">,</span> <span class="nv">length</span><span class="p">:</span> <span class="n">data_size</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[])</span></code></pre></figure>

<p>The vertices above are located in order: bottom left, bottom right and top center. We notice that each vertex uses <strong>4</strong> floats for its coordinate. The first two are the <strong>x</strong> and <strong>y</strong> axes. The ones we do not use this time are: the third one is the <code class="highlighter-rouge">depth (Z-axis)</code> and the fourth one is the <code class="highlighter-rouge">W coordinate</code> making our coordinates <code class="highlighter-rouge">homogeneous</code>. We will talk about them in our next episode. Then we compute the size of this array to simply be the size of <strong>12</strong> floats and finally we create the buffer based on the array and its size. Now that we have our vertexes stored, we need a way to send them to the <code class="highlighter-rouge">GPU</code> so it can display them on the screen. Let’s look at the entire process (<code class="highlighter-rouge">pipeline</code>) that facilitates drawing graphics on the screen:</p>

<p><img src="https://github.com/MetalKit/images/blob/master/chapter03_1.png?raw=true" alt="alt text" title="1" /></p>

<p>We have completed the first stage so far, storing the vertexes. You notice that the next stages require that we have a new construct named <strong>shader</strong>. A <code class="highlighter-rouge">shader</code> is where programmers are allowed to interfere in the graphics pipeline with their custom functions. <code class="highlighter-rouge">Metal</code> provides a few types of shaders, however, today we only look at two of them: the <strong>vertex shader</strong> which is responsible for the <strong>location</strong> of our point, and the <strong>fragment shader</strong> which is responsible for the <strong>color</strong> of our point.</p>

<p>The <code class="highlighter-rouge">Metal</code> framework provides a function that we can call on the <code class="highlighter-rouge">device</code> to create a <strong>Library</strong> of functions (<code class="highlighter-rouge">shaders</code>), so let’s create it:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="k">let</span> <span class="nv">library</span> <span class="o">=</span> <span class="n">device</span><span class="o">!.</span><span class="nf">newDefaultLibrary</span><span class="p">()</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">vertex_func</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="nf">newFunctionWithName</span><span class="p">(</span><span class="s">"vertex_func"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">frag_func</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="nf">newFunctionWithName</span><span class="p">(</span><span class="s">"fragment_func"</span><span class="p">)</span></code></pre></figure>

<p>We create two new <strong>Functions</strong> and point them to their corresponding shaders (which we will create later). The next step is to create a <strong>Render Pipeline Descriptor</strong> which needs to know about our shaders:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="k">let</span> <span class="nv">rpld</span> <span class="o">=</span> <span class="kt">MTLRenderPipelineDescriptor</span><span class="p">()</span>
<span class="n">rpld</span><span class="o">.</span><span class="n">vertexFunction</span> <span class="o">=</span> <span class="n">vertex_func</span>
<span class="n">rpld</span><span class="o">.</span><span class="n">fragmentFunction</span> <span class="o">=</span> <span class="n">frag_func</span>
<span class="n">rpld</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelFormat</span> <span class="o">=</span> <span class="o">.</span><span class="kt">BGRA8Unorm</span></code></pre></figure>

<p>You might wonder what <strong>.BGRA8Unorm</strong> means. This setting configures the pixel format so that everything that goes through the render pipeline conforms to the same order (in this case <code class="highlighter-rouge">Blue</code>, <code class="highlighter-rouge">Green</code>, <code class="highlighter-rouge">Red</code>, <code class="highlighter-rouge">Alpha</code>) of color components as well as size (in this case an <code class="highlighter-rouge">8-bit</code> color value goes from <code class="highlighter-rouge">0</code> to <code class="highlighter-rouge">255</code>). The last step is to create a <strong>Render Pipeline State</strong> based on the above <code class="highlighter-rouge">descriptor</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="k">let</span> <span class="nv">rps</span> <span class="o">=</span> <span class="k">try!</span> <span class="n">device</span><span class="o">!.</span><span class="nf">newRenderPipelineStateWithDescriptor</span><span class="p">(</span><span class="n">rpld</span><span class="p">)</span></code></pre></figure>

<p>Finally, we only need to let the command <code class="highlighter-rouge">encoder</code> know about our triangle, so add the following lines right after creating the <code class="highlighter-rouge">encoder</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="n">command_encoder</span><span class="o">.</span><span class="nf">setRenderPipelineState</span><span class="p">(</span><span class="n">rps</span><span class="p">)</span>
<span class="n">command_encoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">vertex_buffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">atIndex</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">command_encoder</span><span class="o">.</span><span class="nf">drawPrimitives</span><span class="p">(</span><span class="o">.</span><span class="kt">Triangle</span><span class="p">,</span> <span class="nv">vertexStart</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">vertexCount</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nv">instanceCount</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span> </code></pre></figure>

<p>Now let’s get back to the two <code class="highlighter-rouge">shaders</code> we promised to create when we created the <code class="highlighter-rouge">Library</code>. For this, we need to create a new file in <code class="highlighter-rouge">Xcode</code>. Choose the <strong>Metal File</strong> type, name it <strong>Shaders.metal</strong> or something similar and click <code class="highlighter-rouge">Create</code>. You will immediately notice that the code does not resemble <code class="highlighter-rouge">Swift</code> much, and that is because the <code class="highlighter-rouge">Metal shading language</code> is based on <code class="highlighter-rouge">C++</code>. Let’s add the code below:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"> 
<span class="cp">#include &lt;metal_stdlib&gt;
</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">metal</span><span class="p">;</span>

<span class="kd">struct</span> <span class="kt">Vertex</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="p">[[</span><span class="n">position</span><span class="p">]];</span>
<span class="p">};</span>

<span class="n">vertex</span> <span class="kt">Vertex</span> <span class="nf">vertex_func</span><span class="p">(</span><span class="n">constant</span> <span class="kt">Vertex</span> <span class="o">*</span><span class="n">vertices</span> <span class="p">[[</span><span class="nf">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)]],</span> <span class="n">uint</span> <span class="n">vid</span> <span class="p">[[</span><span class="n">vertex_id</span><span class="p">]])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">vertices</span><span class="p">[</span><span class="n">vid</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">fragment</span> <span class="n">float4</span> <span class="nf">fragment_func</span><span class="p">(</span><span class="kt">Vertex</span> <span class="n">vert</span> <span class="p">[[</span><span class="n">stage_in</span><span class="p">]])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">float4</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The code is pretty straightforward. We first create a <code class="highlighter-rouge">struct</code> named <strong>Vertex</strong> that has only one member - an array of position arrays. We notice that the array is <strong>float4</strong> which in the shading language is the same as the vertexes we created earlier with <strong>4</strong> floats each. We leave the explanation for the <strong>[[…]]</strong> syntax for next time. Then we have the <strong>vertex_func</strong> shader which returns the <strong>location</strong> of the current vertex, and the <strong>fragment_func</strong> shader which returns the <strong>color</strong> of the current vertex. We hardcoded a particular color value, but we could have added a <code class="highlighter-rouge">color</code> struct member to <code class="highlighter-rouge">Vertex</code> and set the color separately for each vertex.</p>

<p>If you run the app, you should see a triangle like this:</p>

<p><img src="https://github.com/MetalKit/images/blob/master/chapter03_2.png?raw=true" alt="alt text" title="2" /></p>

<p>In the next part we will learn more about the <code class="highlighter-rouge">Metal shading language</code> as well as how <code class="highlighter-rouge">3D graphics</code> is rendered on the <code class="highlighter-rouge">GPUs</code>. The <a href="https://github.com/MetalKit/metal">source code</a> is posted on Github as usual.</p>

<p>Until next time!</p>

  </div>

  <!-- 
    

   -->

  <div class="a2a_kit a2a_kit_size_32 a2a_default_style"><br />
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_reddit"></a>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_linkedin"></a>
    <a class="a2a_button_email"></a>
  </div>
  <script async src="https://static.addtoany.com/menu/page.js"></script>
</article>
      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper" align="center">

    <!-- <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p> -->

    <!-- Begin MailChimp Signup Form --><p>
    <link href="//cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
    <style type="text/css">
      #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
    </style>
    <div id="mc_embed_signup">
      <form action="//github.us12.list-manage.com/subscribe/post?u=5daab344aba23020915a23c29&amp;id=69e4a7c3af" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
          <div id="mc_embed_signup_scroll">
        <label for="mce-EMAIL">Subscribe to be notified of new posts.</label>
        <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
          <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_5daab344aba23020915a23c29_69e4a7c3af" tabindex="-1" value=""></div>
          <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
          </div>
      </form>
    </div>
    </p><!--End mc_embed_signup-->

    <!-- <h2 class="footer-heading">The Metal Framework</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></p>
        <ul class="contact-list">
          <li>
            
              The Metal Framework
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/MetalKit"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">MetalKit</span></a>

          </li>
          
          
          <li>
            <a href="https://twitter.com/gpu3d"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">gpu3d</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        
          <a href="https://twitter.com/gpu3d"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">gpu3d</span></a>

        
        <p>Resources and tutorials for Metal, MetalKit and Metal Performance Shaders.
</p>
      </div>
    </div> -->

  </div>

</footer>


  </body>

</html>
